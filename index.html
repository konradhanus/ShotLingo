<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TimoAI â€” AI App Store Screenshot Builder & Translator</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        :root {
            --primary-color: #3b82f6;
            --bg-dark: #1e293b;
            --bg-panel: rgba(255, 255, 255, 0.95);
            --text-main: #334155;
            --border-radius: 12px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f1f5f9;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through to canvas */
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        .ui-faded {
            opacity: 0.2;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        /* Top Bar */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: var(--shadow);
            z-index: 100;
            transition: opacity 0.3s;
        }

        .logo { font-weight: bold; font-size: 1.2rem; color: var(--primary-color); display: flex; align-items: center; gap: 10px; }
        
        .actions { display: flex; gap: 10px; align-items: center; }

        .btn {
            background: white;
            border: 1px solid #cbd5e1;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            color: var(--text-main);
        }
        
        .btn:hover { background: #f8fafc; border-color: var(--primary-color); }
        .btn.primary { background: var(--primary-color); color: white; border-color: var(--primary-color); }
        .btn.primary:hover { background: #2563eb; }

        /* Floating Toolbar (Left) */
        .toolbar {
            position: absolute;
            left: 20px;
            top: 80px;
            background: var(--bg-panel);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            padding: 10px;
            gap: 10px;
            z-index: 90;
            transition: opacity 0.3s;
        }

        .tool-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-main);
        }
        
        .tool-btn:hover { background: #f1f5f9; color: var(--primary-color); }
        .tool-btn.active { background: #e0f2fe; color: var(--primary-color); }

        /* JSON Drawer (Right) */
        .drawer {
            position: absolute;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: white;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .drawer.open { right: 0; }
        
        .drawer-header {
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .drawer-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        textarea.json-editor {
            width: 100%;
            flex: 1;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            resize: none;
            background: #f8fafc;
            color: #334155;
        }

        /* Language Switcher */
        .lang-select {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            background: white;
            cursor: pointer;
        }

        /* Property Bar (Bottom/Selected Context) */
        .property-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            padding: 10px 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: none; /* Hidden by default */
            gap: 15px;
            align-items: center;
            z-index: 95;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            max-width: 600px;
        }
        
        .property-bar.visible { display: flex; }

        .prop-group { display: flex; align-items: center; gap: 8px; border-right: 1px solid #e2e8f0; padding-right: 15px; }
        .prop-group:last-child { border-right: none; padding-right: 0; }

        input[type="color"] { width: 30px; height: 30px; border: none; cursor: pointer; background: none; }
        input[type="number"] { width: 60px; padding: 5px; border: 1px solid #cbd5e1; border-radius: 4px; }
        select { padding: 5px; border: 1px solid #cbd5e1; border-radius: 4px; }

        /* Notifications */
        .toast {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: #334155;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 300;
        }
        .toast.show { opacity: 1; }
        
        /* Mobile adjustments */
        @media (max-width: 768px) {
            .drawer { width: 100%; right: -100%; }
            .top-bar { padding: 0 10px; }
            .logo span { display: none; } /* Hide text logo on small screens */
            .toolbar { top: auto; bottom: 100px; left: 10px; }
            .property-bar { bottom: 10px; width: 95%; padding: 10px; }
        }

        /* Dropzone overlay */
        #drop-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(59, 130, 246, 0.8);
            z-index: 500;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            pointer-events: auto;
        }

        /* Layers Panel */
        .layers-panel {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 240px;
            max-height: calc(100% - 280px); /* Avoid overlapping with minimap */
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            z-index: 90;
            display: flex;
            flex-direction: column;
            transition: opacity 0.3s;
            overflow: hidden;
        }

        .layers-header {
            padding: 12px 15px;
            background: rgba(241, 245, 249, 0.5);
            border-bottom: 1px solid #e2e8f0;
            font-weight: bold;
            font-size: 0.85rem;
            color: var(--text-main);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layers-list {
            flex: 1;
            overflow-y: auto;
            padding: 5px 0;
        }

        .layer-item {
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: grab;
            transition: background 0.2s, transform 0.1s;
            border-bottom: 1px solid #f1f5f9;
            background: white;
            user-select: none;
        }

        .layer-item:active { cursor: grabbing; }
        .layer-item.dragging { opacity: 0.5; background: #e2e8f0; transform: scale(0.98); }
        .layer-item.drag-over { border-top: 2px solid var(--primary-color); }
        
        .layer-item.folder { background: #f8fafc; font-weight: 600; }
        .layer-item.nested { padding-left: 35px; }

        .folder-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #64748b;
        }
        
        .folder-toggle:hover { color: var(--primary-color); }

        .layer-info { flex: 1; min-width: 0; }
        .layer-name { 
            font-size: 0.8rem; 
            font-weight: 500; 
            color: #334155; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            flex: 1; 
            pointer-events: auto;
            user-select: none;
            padding: 2px 0;
        }
        .layer-name-input {
            font-size: 0.8rem;
            border: 1px solid var(--primary-color);
            border-radius: 4px;
            padding: 2px 5px;
            width: 100%;
            outline: none;
            font-family: inherit;
        }
        .layer-item.active { background: #e0f2fe; border-left: 3px solid var(--primary-color); }
        .layer-item.moving { 
            background: #dbeafe; 
            border-left: 3px solid var(--primary-color);
            box-shadow: inset 0 0 10px rgba(59, 130, 246, 0.1);
        }
        .layer-type { font-size: 0.65rem; color: #94a3b8; text-transform: uppercase; }

        .layer-actions { display: flex; gap: 5px; }
        .layer-action-btn {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: transparent;
            color: #94a3b8;
            cursor: pointer;
            border-radius: 4px;
        }
        .layer-action-btn:hover { background: #cbd5e1; color: #334155; }
        .layer-action-btn.hidden, .layer-action-btn.locked { color: var(--primary-color); opacity: 1; }
        .layer-item.is-locked { background: #f8fafc; opacity: 0.8; }
        
        /* Layers Folder Controls */
        .layers-controls {
            padding: 8px 15px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
            background: #fff;
        }
        
        .btn-icon-sm {
            padding: 4px 8px;
            font-size: 0.8rem;
            background: #f1f5f9;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
            color: #64748b;
        }
        
        .btn-icon-sm:hover { background: #e2e8f0; color: var(--primary-color); }

        /* Minimap */
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 160px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 100;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #minimap {
            background: #f8fafc;
            cursor: grab;
            width: 100%;
            height: 100%;
        }
        
        #minimap:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>

    <!-- Canvas Container -->
    <div id="canvas-container">
        <canvas id="c"></canvas>
    </div>

    <!-- Drag Drop Overlay -->
    <div id="drop-overlay">UpuÅ›Ä‡ plik tutaj</div>

    <!-- UI Layer -->
    <div id="ui-layer">
        
        <!-- Top Bar -->
        <div class="top-bar pointer-events-auto">
            <div class="logo">
                <i class="fa-solid fa-layer-group"></i> <span>Timo AI</span>
            </div>
            
            <div class="actions">
                <select id="lang-switcher" class="lang-select">
                    <option value="en-US">ðŸ‡¬ðŸ‡§ en-US (Base)</option>
                    <option value="pl-PL">ðŸ‡µðŸ‡± pl-PL</option>
                    <option value="de-DE">ðŸ‡©ðŸ‡ª de-DE</option>
                    <option value="fr-FR">ðŸ‡«ðŸ‡· fr-FR</option>
                    <option value="es-ES">ðŸ‡ªðŸ‡¸ es-ES</option>
                </select>
                
                <button class="btn" onclick="toggleDrawer()">
                    <i class="fa-solid fa-code"></i> JSON
                </button>
                
                <div style="display:flex; align-items:center; gap:5px; margin-right:10px;">
                    <input type="checkbox" id="safe-area-toggle" onchange="toggleSafeAreas(this.checked)">
                    <span style="font-size:0.8rem; color:#64748b; cursor:pointer;" onclick="document.getElementById('safe-area-toggle').click()">Safe Area</span>
                </div>

                <div style="display:flex; align-items:center; gap:5px; margin-right:10px;">
                    <span style="font-size:0.8rem; color:#64748b;">TÅ‚o:</span>
                    <input type="color" id="global-bg-picker" value="#ffffff" title="ZmieÅ„ tÅ‚o wszystkich ekranÃ³w" onchange="setGlobalBackground(this.value)">
                </div>

                <div style="height: 24px; width: 1px; background: #e2e8f0; margin: 0 5px;"></div>

                <button class="btn" onclick="setGeminiKey()" title="Ustaw klucz API Gemini">
                    <i class="fa-solid fa-key"></i>
                </button>
                
                <div id="ai-model-container" style="display:none; align-items:center; gap:5px;">
                    <select id="gemini-model-select" class="lang-select" style="max-width: 150px;" onchange="saveGeminiModel(this.value)">
                        <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                    </select>
                    <button class="btn" id="ai-translate-btn" onclick="translateWithGemini()" style="background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); color: white; border: none;">
                        <i class="fa-solid fa-wand-magic-sparkles"></i> AI Translate
                    </button>
                </div>

                <div style="height: 24px; width: 1px; background: #e2e8f0; margin: 0 5px;"></div>

                <button class="btn primary" onclick="exportScreenshots()">
                    <i class="fa-solid fa-download"></i> Eksportuj
                </button>
            </div>
        </div>

        <!-- Left Toolbar -->
        <div class="toolbar pointer-events-auto">
            <button class="tool-btn" onclick="addText()" title="Dodaj Tekst">
                <i class="fa-solid fa-font"></i>
            </button>
            <button class="tool-btn" onclick="triggerImageUpload()" title="Dodaj Obraz">
                <i class="fa-solid fa-image"></i>
            </button>
            <input type="file" id="img-upload" hidden accept="image/*" onchange="handleImageUpload(this)">
            
            <button class="tool-btn" onclick="addFrame('ios_65')" title="Ramka iOS 6.5">
                <i class="fa-brands fa-apple"></i>
            </button>
            <button class="tool-btn" onclick="addFrame('android_phone')" title="Ramka Android">
                <i class="fa-brands fa-android"></i>
            </button>
            
            <div style="height: 1px; background: #e2e8f0; margin: 5px 0;"></div>

            <button class="tool-btn" id="pan-tool" onclick="togglePanMode()" title="Przesuwanie (Spacja)">
                <i class="fa-solid fa-hand"></i>
            </button>
        </div>

        <!-- Property Bar (Contextual) -->
        <div class="property-bar pointer-events-auto" id="prop-bar">
            <!-- Text Properties -->
            <div id="text-props" class="prop-group" style="display:none;">
                <select id="font-family" onchange="updateActiveObject('fontFamily', this.value)">
                    <option value="Arial">Arial</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Verdana">Verdana</option>
                </select>
                <input type="number" id="font-size" value="40" onchange="updateActiveObject('fontSize', parseInt(this.value))">
                <button class="btn" style="padding: 5px 10px;" onclick="toggleBold()"><i class="fa-solid fa-bold"></i></button>
                <button class="btn" style="padding: 5px 10px;" onclick="toggleItalic()"><i class="fa-solid fa-italic"></i></button>
                <!-- Alignment -->
                <button class="btn" style="padding: 5px 10px;" onclick="setTextAlign('left')"><i class="fa-solid fa-align-left"></i></button>
                <button class="btn" style="padding: 5px 10px;" onclick="setTextAlign('center')"><i class="fa-solid fa-align-center"></i></button>
                <button class="btn" style="padding: 5px 10px;" onclick="setTextAlign('right')"><i class="fa-solid fa-align-right"></i></button>
            </div>

            <!-- Frame Specific Properties -->
            <div id="frame-props" class="prop-group" style="display:none;">
                <span style="font-size: 0.8rem; color: #64748b; margin-right: 5px;">Klonuj do:</span>
                <select id="clone-target" onchange="cloneFrameTo(this.value)">
                    <option value="">Wybierz...</option>
                    <option value="ios_65">iPhone 6.5"</option>
                    <option value="ios_55">iPhone 5.5"</option>
                    <option value="ipad_129">iPad 12.9"</option>
                    <option value="android_phone">Android Phone</option>
                    <option value="android_tablet7">Android Tablet 7"</option>
                    <option value="android_tablet10">Android Tablet 10"</option>
                </select>
            </div>

            <!-- Image Specific Properties -->
            <div id="image-props" class="prop-group" style="display:none;">
                <span style="font-size: 0.8rem; color: #64748b;">W:</span>
                <input type="number" id="img-width" onchange="updateImageProp('width', this.value)">
                <span style="font-size: 0.8rem; color: #64748b;">H:</span>
                <input type="number" id="img-height" onchange="updateImageProp('height', this.value)">
                <span style="font-size: 0.8rem; color: #64748b;"><i class="fa-solid fa-border-all"></i></span>
                <input type="number" id="img-radius" value="0" placeholder="R" onchange="updateImageProp('radius', this.value)">
            </div>

            <!-- Common Properties -->
            <div class="prop-group">
                <input type="color" id="fill-color" onchange="updateActiveObject('fill', this.value)">
                <button class="btn" id="ratio-lock-btn" style="padding: 5px 10px;" onclick="toggleAspectRatio()" title="Zablokuj/Odblokuj proporcje">
                    <i class="fa-solid fa-lock"></i>
                </button>
            </div>
            
            <!-- Layer Properties -->
            <div class="prop-group">
                <button class="btn" style="padding: 5px;" onclick="bringToFront()" title="Na wierzch"><i class="fa-solid fa-arrow-up"></i></button>
                <button class="btn" style="padding: 5px;" onclick="sendToBack()" title="Na spÃ³d"><i class="fa-solid fa-arrow-down"></i></button>
                <button class="btn" style="padding: 5px;" onclick="deleteActive()" title="UsuÅ„"><i class="fa-solid fa-trash text-red-500"></i></button>
            </div>
        </div>

        <!-- JSON Drawer -->
        <div class="drawer pointer-events-auto" id="json-drawer">
            <div class="drawer-header">
                <span>Localization Hub (JSON)</span>
                <button class="tool-btn" onclick="toggleDrawer()"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="drawer-content">
                <p style="font-size: 0.8rem; color: #64748b;">
                    Edytuj teksty poniÅ¼ej lub skopiuj do AI (np. ChatGPT), aby przetÅ‚umaczyÄ‡ na inne jÄ™zyki.
                </p>
                <div class="actions" style="margin-bottom: 10px;">
                    <button class="btn" onclick="copyJSON()">Kopiuj</button>
                    <button class="btn primary" onclick="applyJSON()">Zastosuj</button>
                </div>
                <textarea id="json-editor" class="json-editor"></textarea>
            </div>
        </div>

        <!-- Layers Panel -->
        <div class="layers-panel pointer-events-auto" id="layers-panel">
            <div class="layers-header">
                <span>WARSTWY</span>
                <div style="display: flex; gap: 5px;">
                    <button class="btn-icon-sm" onclick="createNewFolder()" title="Nowy Folder">
                        <i class="fa-solid fa-folder-plus"></i>
                    </button>
                    <i class="fa-solid fa-layer-group" style="opacity: 0.5; margin-left: 5px;"></i>
                </div>
            </div>
            <div class="layers-list" id="layers-list" ondragover="event.preventDefault()" ondrop="handleRootDrop(event)">
                <!-- Layers will be injected here -->
            </div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap-container" class="pointer-events-auto">
            <canvas id="minimap"></canvas>
        </div>

        <!-- Toast Notification -->
        <div id="toast" class="toast">Action completed</div>

    </div>

    <script>
        // --- 1. STATE MANAGEMENT ---
        const state = {
            currentLang: 'en-US',
            translations: {
                'en-US': {},
                'pl-PL': {},
                'de-DE': {},
                'fr-FR': {},
                'es-ES': {}
            },
            canvasBg: '#f0f0f0',
            clipboard: null,
            undoStack: [],
            redoStack: [],
            isProcessingHistory: false
        };

        // --- 2. CONFIGURATION ---
        const FRAMES = {
            'ios_65': { width: 1284, height: 2778, name: 'iPhone 6.5"' },
            'ios_55': { width: 1242, height: 2208, name: 'iPhone 5.5"' },
            'ipad_129': { width: 2048, height: 2732, name: 'iPad 12.9"' },
            'android_phone': { width: 1080, height: 1920, name: 'Android Phone' },
            'android_tablet7': { width: 1200, height: 1920, name: 'Android Tablet 7"' },
            'android_tablet10': { width: 1600, height: 2560, name: 'Android Tablet 10"' },
        };

        // --- 3. CANVAS SETUP ---
        const canvas = new fabric.Canvas('c', {
            backgroundColor: '#f1f5f9',
            preserveObjectStacking: true,
            selection: true,
            uniformScaling: true,
            fireMiddleClick: true, // Required for middle click events
            stopContextMenu: true  // Good practice when using right/middle click
        });

        // Prevent browser's middle-click autoscroll
        canvas.upperCanvasEl.addEventListener('mousedown', function(e) {
            if (e.button === 1) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, { passive: false });

        // --- HISTORY (UNDO/REDO) ---
        function saveHistory() {
            if (state.isProcessingHistory) return;
            
            // Limit stack size to 50 for performance
            if (state.undoStack.length > 50) state.undoStack.shift();
            
            // Don't serialize 'frameLabel' (runtime ref), use IDs instead
            state.undoStack.push(JSON.stringify(canvas.toJSON(['id', 'textId', 'isFrame', 'deviceName', 'isSafeArea', 'linkedFrameId', 'folderId', 'customName', 'borderRadius', 'uniformScaling', 'locked'])));
            state.redoStack = []; // Clear redo on new action
        }

        function undo() {
            if (state.undoStack.length <= 1) return; // Keep initial state
            
            state.isProcessingHistory = true;
            const currentState = state.undoStack.pop();
            state.redoStack.push(currentState);
            
            const prevState = state.undoStack[state.undoStack.length - 1];
            
            canvas.loadFromJSON(prevState, function() {
                const objects = canvas.getObjects();
                
                // Restore frame-label links
                const frames = objects.filter(o => o.isFrame);
                const labels = objects.filter(o => o.linkedFrameId);

                // 1. Try ID based linking (New robust way)
                labels.forEach(label => {
                    const frame = frames.find(f => f.id === label.linkedFrameId);
                    if (frame) frame.frameLabel = label;
                });

                // 2. Fallback heuristic (Old way, for pre-ID states in stack)
                frames.forEach(frame => {
                    if (!frame.frameLabel && frame.deviceName) {
                        frame.frameLabel = objects.find(o => 
                            !o.selectable && 
                            o.text === frame.deviceName && 
                            o.top < frame.top && 
                            Math.abs(o.left - frame.left) < 5 // Check alignment too
                        );
                    }
                });
                
                canvas.renderAll();
                state.isProcessingHistory = false;
                showToast("CofniÄ™to zmianÄ™");
            });
        }

        // Keyboard listeners
        window.addEventListener('keydown', function(e) {
            // Ignore if focus is on an input/textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // Ctrl + Z (Undo)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }

            // Ctrl + C (Copy)
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                e.preventDefault();
                copy();
            }

            // Ctrl + V (Paste)
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                e.preventDefault();
                paste();
            }

            // Ctrl + A (Select All)
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                canvas.discardActiveObject();
                const sel = new fabric.ActiveSelection(canvas.getObjects().filter(o => !o.excludeFromExport), {
                    canvas: canvas,
                });
                canvas.setActiveObject(sel);
                canvas.requestRenderAll();
            }
            
            // Delete / Backspace (Delete Active)
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // Check if not editing text inside canvas
                const active = canvas.getActiveObject();
                if (active && !active.isEditing) {
                    e.preventDefault();
                    deleteActive();
                }
            }

            // Arrow Keys (Move Objects)
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                const activeObj = canvas.getActiveObject();
                if (activeObj && !activeObj.isEditing) {
                    e.preventDefault();
                    const step = e.shiftKey ? 10 : 1;
                    
                    switch (e.key) {
                        case 'ArrowUp': activeObj.top -= step; break;
                        case 'ArrowDown': activeObj.top += step; break;
                        case 'ArrowLeft': activeObj.left -= step; break;
                        case 'ArrowRight': activeObj.left += step; break;
                    }
                    
                    activeObj.setCoords();
                    
                    // If moving a frame, update its label and clips
                    if (activeObj.isFrame) {
                        if (activeObj.frameLabel) {
                            activeObj.frameLabel.set({
                                left: activeObj.left,
                                top: activeObj.top - 50
                            });
                        }
                        syncFrameClips(activeObj);
                        updateSafeAreaPosition(activeObj);
                    }
                    
                    canvas.requestRenderAll();
                    debouncedSave();
                }
            }
        });

        // --- COPY / PASTE ---
        function copy() {
            const activeObj = canvas.getActiveObject();
            if (!activeObj) return;
            
            activeObj.clone(function(cloned) {
                state.clipboard = cloned;
                showToast("Skopiowano");
            }, ['textId', 'isFrame', 'deviceName', 'isSafeArea', 'frameLabel', 'uniformScaling']);
        }

        function paste() {
            if (!state.clipboard) return;
            
            state.clipboard.clone(function(clonedObj) {
                canvas.discardActiveObject();
                
                clonedObj.set({
                    left: clonedObj.left + 20,
                    top: clonedObj.top + 20,
                    evented: true,
                });

                if (clonedObj.type === 'activeSelection') {
                    // Active selection needs a canvas reference
                    clonedObj.canvas = canvas;
                    clonedObj.forEachObject(function(obj) {
                        canvas.add(obj);
                        handlePastedObject(obj);
                    });
                    clonedObj.setCoords();
                } else {
                    canvas.add(clonedObj);
                    handlePastedObject(clonedObj);
                }
                
                // Fix: if we pasted a frame, we need to handle its label if it wasn't part of a group selection
                // But since 'frameLabel' link is custom, standard clone won't deep copy the label instance unless we manually do it.
                // For simplicity in this prototype, we might lose the label link or it points to original. 
                // Let's rely on `handlePastedObject` to fix basic props.
                
                canvas.setActiveObject(clonedObj);
                canvas.requestRenderAll();
                saveHistory();
                saveLocalState();
                showToast("Wklejono");
            }, ['textId', 'isFrame', 'deviceName', 'isSafeArea', 'frameLabel', 'uniformScaling']);
        }

        function handlePastedObject(obj) {
            // 1. Handle IDs (New Instance = New ID)
            const oldId = obj.id;
            const newId = uuidv4();
            obj.id = newId;
            
            // If it had translations, copy them over to the new ID
            if (oldId && state.translations) {
                Object.keys(state.translations).forEach(lang => {
                    const text = state.translations[lang][oldId];
                    if (text !== undefined) {
                        state.translations[lang][newId] = text;
                    }
                });
            }

            // 2. Handle Frames (need new labels)
            if (obj.isFrame && obj.deviceName) {
                // Generate new ID for the pasted frame
                const newFrameId = uuidv4();
                obj.id = newFrameId;

                const newLabel = new fabric.Text(obj.deviceName, {
                    left: obj.left,
                    top: obj.top - 50,
                    fontSize: 30,
                    fill: '#64748b',
                    selectable: false,
                    evented: false,
                    excludeFromExport: true,
                    linkedFrameId: newFrameId // Link to new frame ID
                });
                
                obj.frameLabel = newLabel;
                canvas.add(newLabel);
                canvas.sendToBack(obj); // Ensure frame is behind
            }
        }

        // Listen for canvas changes
        canvas.on('object:added', () => { 
            saveHistory(); 
            debouncedSave(); 
            if (typeof updateLayersPanel === 'function') updateLayersPanel(); 
        });
        canvas.on('object:modified', () => { 
            saveHistory(); 
            debouncedSave(); 
            if (typeof updateLayersPanel === 'function') updateLayersPanel(); 
        });
        canvas.on('object:removed', () => { 
            saveHistory(); 
            debouncedSave(); 
            if (typeof updateLayersPanel === 'function') updateLayersPanel(); 
        });
        canvas.on('text:changed', () => { 
            saveHistory(); 
            debouncedSave(); 
            if (typeof updateLayersPanel === 'function') updateLayersPanel(); 
        });

        // --- LOCAL STORAGE PERSISTENCE (UPGRADED TO INDEXEDDB WITH LOCALSTORAGE FALLBACK) ---
        const LOCAL_STORAGE_KEY = 'timo_v1_db';
        let saveTimeout = null;

        function debouncedSave() {
            // Show "Saving..." status immediately
            const t = document.getElementById('toast');
            if (t.textContent !== "Zapisywanie...") {
                t.textContent = "Zapisywanie...";
                t.classList.add('show');
            }

            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveLocalState, 300); // 300ms for snappier feel
        }

        async function saveLocalState() {
            if (state.isProcessingHistory) return;

            const dataToSave = {
                version: '1.2',
                currentLang: state.currentLang,
                translations: state.translations,
                folders: state.folders,
                viewport: {
                    zoom: canvas.getZoom(),
                    transform: canvas.viewportTransform
                },
                canvas: canvas.toJSON(['id', 'textId', 'isFrame', 'deviceName', 'isSafeArea', 'linkedFrameId', 'clippedByFrameId', 'folderId', 'customName', 'borderRadius', 'uniformScaling', 'locked'])
            };

            try {
                // Try LocalForage (IndexedDB)
                if (typeof localforage !== 'undefined') {
                    await localforage.setItem(LOCAL_STORAGE_KEY, dataToSave);
                } else {
                    throw new Error('localforage undefined');
                }
                
                const t = document.getElementById('toast');
                t.textContent = "Zapisano";
                setTimeout(() => { if(t.textContent === "Zapisano") t.classList.remove('show') }, 1000);
            } catch (e) {
                console.warn('Failed to save to IndexedDB, trying LocalStorage', e);
                try {
                    // Fallback to standard LocalStorage
                    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
                    const t = document.getElementById('toast');
                    t.textContent = "Zapisano (LS)";
                    setTimeout(() => { if(t.textContent === "Zapisano (LS)") t.classList.remove('show') }, 1000);
                } catch (lsError) {
                    console.error('Persistence failed completely', lsError);
                    showToast('BÅ‚Ä…d zapisu! (Brak miejsca?)');
                }
            }
        }

        async function loadLocalState() {
            try {
                let savedData = null;
                
                // 1. Try LocalForage
                if (typeof localforage !== 'undefined') {
                    savedData = await localforage.getItem(LOCAL_STORAGE_KEY);
                }
                
                // 2. Try LocalStorage Fallback
                if (!savedData) {
                    const raw = localStorage.getItem(LOCAL_STORAGE_KEY);
                    if (raw) savedData = JSON.parse(raw);
                }

                if (!savedData) {
                    saveHistory(); // Initialize history
                    return;
                }
                
                // Restore State
                state.currentLang = savedData.currentLang || 'en-US';
                state.translations = savedData.translations || state.translations;
                state.folders = savedData.folders || [];
                
                // Update UI for state
                document.getElementById('lang-switcher').value = state.currentLang;
                updateJSONEditor();
                updateLayersPanel();
                updateLangSwitcher();

                // Restore Canvas
                if (savedData.canvas) {
                    state.isProcessingHistory = true;
                    canvas.loadFromJSON(savedData.canvas, function() {
                        // Restore Viewport
                        if (savedData.viewport) {
                            canvas.setZoom(savedData.viewport.zoom || 1);
                            if (savedData.viewport.transform) {
                                canvas.viewportTransform = savedData.viewport.transform;
                            }
                        }

                        const objects = canvas.getObjects();
                        
                        // HEALING: Ensure EVERY object has a unique ID and standardize textId to id
                        objects.forEach(obj => {
                            if (!obj.id) {
                                obj.id = obj.textId || uuidv4();
                            }
                            // Cleanup old property if exists
                            delete obj.textId;

                            // Apply locked state if preserved
                            if (obj.locked) {
                                obj.selectable = false;
                                obj.evented = false;
                            }
                            
                            // Sanitize device names in existing frames to avoid export issues
                            if (obj.isFrame && obj.deviceName) {
                                obj.deviceName = obj.deviceName.replace(/["<>:"/\\|?*]/g, '');
                            }
                        });

                        // Restore frame-label links using IDs
                        const frames = objects.filter(o => o.isFrame);
                        const linkedObjects = objects.filter(o => o.linkedFrameId);

                        linkedObjects.forEach(obj => {
                            const frame = frames.find(f => f.id === obj.linkedFrameId);
                            if (frame) {
                                if (obj.isSafeArea) {
                                    frame.safeArea = obj;
                                } else {
                                    frame.frameLabel = obj;
                                }
                            }
                        });
                        
                        canvas.renderAll();
                        state.isProcessingHistory = false;
                        saveHistory();
                        showToast("PrzywrÃ³cono sesjÄ™");
                    });
                }
            } catch (e) {
                console.error('Error loading state', e);
                saveHistory();
            }
        }

        // Initial load
        loadLocalState();

        // --- GRID IMPLEMENTATION ---
        const gridSize = 50;
        
        canvas.on('before:render', function() {
            const context = canvas.getContext();
            const vpt = canvas.viewportTransform;
            const zoom = canvas.getZoom();
            
            // Only draw grid if zoom is reasonable
            if (zoom < 0.2) return;

            const viewportWidth = canvas.width / zoom;
            const viewportHeight = canvas.height / zoom;
            
            const startX = -vpt[4] / zoom;
            const startY = -vpt[5] / zoom;
            const endX = startX + viewportWidth;
            const endY = startY + viewportHeight;

            context.beginPath();
            context.strokeStyle = '#e2e8f0';
            context.lineWidth = 1 / zoom;

            // Vertical lines
            const offsetX = startX % gridSize;
            for (let i = startX - offsetX; i < endX; i += gridSize) {
                const screenX = (i * zoom) + vpt[4];
                context.moveTo(screenX, 0);
                context.lineTo(screenX, canvas.height);
            }

            // Horizontal lines
            const offsetY = startY % gridSize;
            for (let i = startY - offsetY; i < endY; i += gridSize) {
                const screenY = (i * zoom) + vpt[5];
                context.moveTo(0, screenY);
                context.lineTo(canvas.width, screenY);
            }
            
            context.stroke();
        });

        // --- CLIPPING / MASKING LOGIC ---
        
        function toggleObjectLock(obj) {
            obj.locked = !obj.locked;
            obj.selectable = !obj.locked;
            obj.evented = !obj.locked;
            obj.hoverCursor = obj.locked ? 'not-allowed' : 'move';
            
            canvas.discardActiveObject();
            canvas.renderAll();
            updateLayersPanel();
            saveLocalState();
        }

        function toggleFolderLock(folder) {
            folder.locked = !folder.locked;
            // Lock all objects in this folder
            canvas.getObjects().forEach(obj => {
                if (obj.folderId === folder.id) {
                    obj.locked = folder.locked;
                    obj.selectable = !folder.locked;
                    obj.evented = !folder.locked;
                }
            });
            canvas.discardActiveObject();
            canvas.renderAll();
            updateLayersPanel();
            saveLocalState();
        }

        function checkForClipping(obj) {
            if (!obj || obj.isFrame || obj.type !== 'image') return;

            const center = obj.getCenterPoint();
            const frames = canvas.getObjects().filter(o => o.isFrame);
            
            // Find frame that contains the image center
            const targetFrame = frames.find(f => f.containsPoint(center));
            
            if (targetFrame) {
                // If it's a new frame or not clipped yet
                if (obj.clippedByFrameId !== targetFrame.id) {
                    // Bring object above the frame to ensure visibility
                    const frameIndex = canvas.getObjects().indexOf(targetFrame);
                    const objIndex = canvas.getObjects().indexOf(obj);
                    if (objIndex < frameIndex) {
                        obj.moveTo(frameIndex + 1);
                    }
                }

                const clipRect = new fabric.Rect({
                    left: targetFrame.left,
                    top: targetFrame.top,
                    width: targetFrame.width,
                    height: targetFrame.height,
                    scaleX: targetFrame.scaleX,
                    scaleY: targetFrame.scaleY,
                    angle: targetFrame.angle,
                    rx: targetFrame.rx,
                    ry: targetFrame.ry,
                    absolutePositioned: true,
                    originX: targetFrame.originX,
                    originY: targetFrame.originY
                });

                obj.clipPath = clipRect;
                obj.clippedByFrameId = targetFrame.id;
                obj.dirty = true;
            } else {
                // Not over any frame - CLEAR clipping
                if (obj.clippedByFrameId) {
                    obj.clipPath = null;
                    delete obj.clippedByFrameId;
                    
                    // Re-apply border radius if it existed
                    if (obj.borderRadius > 0) {
                        applyImageRadius(obj, obj.borderRadius);
                    }
                    obj.dirty = true;
                }
            }
            canvas.requestRenderAll();
            updateLayersPanel();
        }

        function syncFrameClips(frame) {
            if (!frame.isFrame) return;
            
            const objs = canvas.getObjects();
            objs.forEach(obj => {
                if (obj.clippedByFrameId === frame.id && obj.clipPath) {
                    // Update the mask to match the frame's new transform
                    obj.clipPath.set({
                        left: frame.left,
                        top: frame.top,
                        width: frame.width,
                        height: frame.height,
                        scaleX: frame.scaleX,
                        scaleY: frame.scaleY,
                        angle: frame.angle,
                        skewX: frame.skewX,
                        skewY: frame.skewY
                    });
                    obj.dirty = true;
                }
            });
        }

        // --- SNAPPING LOGIC ---
        const SNAP_DIST = 10;
        
        canvas.on('object:moving', function(e) {
            const obj = e.target;
            obj.isMoving = true;
            updateLayersPanel();
            const vpt = canvas.viewportTransform;
            
            // Snap to Grid
            if (!e.e.shiftKey) { // Hold shift to disable snap
                obj.left = Math.round(obj.left / gridSize) * gridSize;
                obj.top = Math.round(obj.top / gridSize) * gridSize;
            }
            
            // Move Linked Label (if Frame)
            if (obj.isFrame && obj.frameLabel) {
                obj.frameLabel.set({
                    left: obj.left,
                    top: obj.top - 50 // Keep relative offset
                });
            }

            // Sync clips if moving a frame
            if (obj.isFrame) {
                syncFrameClips(obj);
                updateSafeAreaPosition(obj);
            }
        });

        canvas.on('object:scaling', function(e) {
            const obj = e.target;
            obj.isMoving = true;
            updateLayersPanel();

            if (obj.type === 'image') {
                imgWidthInput.value = Math.round(obj.width * obj.scaleX);
                imgHeightInput.value = Math.round(obj.height * obj.scaleY);
            }

            if (obj.isFrame) {
                syncFrameClips(e.target);
                updateSafeAreaPosition(e.target);
            }
        });

        canvas.on('object:rotating', function(e) {
            e.target.isMoving = true;
            updateLayersPanel();
        });

        // Resize handling
        function resizeCanvas() {
            canvas.setWidth(window.innerWidth);
            canvas.setHeight(window.innerHeight);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- 4. PANNING & ZOOMING (Infinite Canvas) ---
        let isPanning = false;
        let lastPosX, lastPosY;

        // Desktop Wheel Zoom
        canvas.on('mouse:wheel', function(opt) {
            var delta = opt.e.deltaY;
            var zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            if (zoom > 20) zoom = 20;
            if (zoom < 0.01) zoom = 0.01;
            canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
            opt.e.preventDefault();
            opt.e.stopPropagation();
            debouncedSave();
        });

        // Touch Gestures (Pinch Zoom & Pan)
        let lastTouchDistance = 0;
        let isTouchDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;

        canvas.upperCanvasEl.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                // Pinch start
                isTouchDragging = false;
                const p1 = {x: e.touches[0].clientX, y: e.touches[0].clientY};
                const p2 = {x: e.touches[1].clientX, y: e.touches[1].clientY};
                lastTouchDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            } else if (e.touches.length === 1) {
                // Pan start (if mode is active or implicitly on bg)
                const target = canvas.findTarget(e);
                // Allow pan if not targeting an object or if pan tool is active
                if (!target || document.getElementById('pan-tool').classList.contains('active')) {
                     isTouchDragging = true;
                     lastTouchX = e.touches[0].clientX;
                     lastTouchY = e.touches[0].clientY;
                }
            }
        });

        canvas.upperCanvasEl.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2) {
                // Pinch Zoom
                e.preventDefault(); // Prevent browser zoom
                const p1 = {x: e.touches[0].clientX, y: e.touches[0].clientY};
                const p2 = {x: e.touches[1].clientX, y: e.touches[1].clientY};
                const currentDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);

                if (lastTouchDistance > 0) {
                    const scale = currentDistance / lastTouchDistance;
                    let zoom = canvas.getZoom() * scale;
                    if (zoom > 5) zoom = 5;
                    if (zoom < 0.1) zoom = 0.1;
                    
                    // Zoom to center of pinch
                    const centerPoint = new fabric.Point(
                        (p1.x + p2.x) / 2,
                        (p1.y + p2.y) / 2
                    );
                    
                    canvas.zoomToPoint(centerPoint, zoom);
                    canvas.requestRenderAll();
                }
                lastTouchDistance = currentDistance;
            } else if (e.touches.length === 1 && isTouchDragging) {
                // Touch Pan
                e.preventDefault();
                const x = e.touches[0].clientX;
                const y = e.touches[0].clientY;
                const vpt = canvas.viewportTransform;
                vpt[4] += x - lastTouchX;
                vpt[5] += y - lastTouchY;
                canvas.requestRenderAll();
                lastTouchX = x;
                lastTouchY = y;
            }
        });

        canvas.upperCanvasEl.addEventListener('touchend', function(e) {
            isTouchDragging = false;
            lastTouchDistance = 0;
        });

        function handleMultiSelect(obj, activeObject) {
            if (!activeObject) {
                canvas.setActiveObject(obj);
            } else if (activeObject.type === 'activeSelection') {
                if (activeObject.contains(obj)) {
                    activeObject.removeWithUpdate(obj);
                    if (activeObject.size() === 1) canvas.setActiveObject(activeObject.item(0));
                } else {
                    activeObject.addWithUpdate(obj);
                }
            } else {
                if (activeObject !== obj) {
                    const sel = new fabric.ActiveSelection([activeObject, obj], { canvas: canvas });
                    canvas.setActiveObject(sel);
                } else {
                    canvas.discardActiveObject();
                }
            }
        }

        canvas.on('mouse:down', function(opt) {
            // If user clicks empty space or a different object, clear isolation
            if (canvas.isLayerIsolated) {
                const target = opt.target;
                const active = canvas.getActiveObject();
                
                // If clicked on background or a new object (not the isolated one)
                if (!target || target !== active) {
                    canvas.getObjects().forEach(obj => {
                        if (!obj.locked) obj.evented = true;
                    });
                    canvas.isLayerIsolated = false;
                    updateLayersPanel();
                }
            }
            
            var evt = opt.e;
            // Alt Key, Pan Tool active, OR Middle Mouse Button (button === 1)
            if (evt.altKey || document.getElementById('pan-tool').classList.contains('active') || evt.button === 1) {
                this.isDragging = true;
                this.selection = false;
                this.lastPosX = evt.clientX;
                this.lastPosY = evt.clientY;
                this.defaultCursor = 'grabbing';
                this.setCursor('grabbing');
                
                // Discard active object to prevent accidental moves while panning
                canvas.discardActiveObject();
                canvas.requestRenderAll();
            }
        });

        canvas.on('mouse:move', function(opt) {
            if (this.isDragging) {
                var e = opt.e;
                var vpt = this.viewportTransform;
                vpt[4] += e.clientX - this.lastPosX;
                vpt[5] += e.clientY - this.lastPosY;
                this.requestRenderAll();
                this.lastPosX = e.clientX;
                this.lastPosY = e.clientY;
            }
        });

        canvas.on('mouse:up', function(opt) {
            const active = canvas.getActiveObject();
            if (active) {
                active.isMoving = false;
                updateLayersPanel();
            }
            if (this.isDragging) {
                debouncedSave();
            }
            this.setViewportTransform(this.viewportTransform);
            this.isDragging = false;
            this.selection = true;
            
            // Reset cursor if pan tool is not active
            if (!document.getElementById('pan-tool').classList.contains('active')) {
                this.defaultCursor = 'default';
                this.setCursor('default');
            }

            // Check for clipping on drop
            if (opt.target) checkForClipping(opt.target);
        });

        function togglePanMode() {
            const btn = document.getElementById('pan-tool');
            btn.classList.toggle('active');
            canvas.defaultCursor = btn.classList.contains('active') ? 'grab' : 'default';
        }

        // --- 5. LOGIC: ADDING OBJECTS ---

        // Helper: Generate UUID
        function uuidv4() {
            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        // Add Text
        function addText(initialText = "NagÅ‚Ã³wek") {
            const id = uuidv4();
            const textObj = new fabric.Textbox(initialText, {
                id: id,
                left: 100 - canvas.viewportTransform[4],
                top: 100 - canvas.viewportTransform[5],
                width: 300,
                fontSize: 40,
                fontFamily: 'Arial',
                fill: '#000000',
                textAlign: 'center'
            });

            // Add to translation state for ALL languages
            Object.keys(state.translations).forEach(lang => {
                state.translations[lang][id] = initialText;
            });

            canvas.add(textObj);
            canvas.setActiveObject(textObj);
            updateJSONEditor();
        }

        // Add Frame
        function addFrame(type) {
            const config = FRAMES[type];
            if (!config) return;

            const frameId = uuidv4();
            const folderId = 'folder_' + uuidv4();

            const rect = new fabric.Rect({
                left: (window.innerWidth / 2 - config.width / 4) - canvas.viewportTransform[4],
                top: (window.innerHeight / 2 - config.height / 4) - canvas.viewportTransform[5],
                width: config.width,
                height: config.height,
                fill: '#ffffff',
                stroke: '#cbd5e1',
                strokeWidth: 2,
                rx: 40,
                ry: 40,
                shadow: '0 10px 20px rgba(0,0,0,0.1)',
                objectCaching: false,
                isFrame: true,
                deviceName: config.name,
                id: frameId,
                folderId: folderId // Put frame inside its own folder
            });
            
            // Text Label for the frame
            const label = new fabric.Text(config.name, {
                left: rect.left,
                top: rect.top - 50,
                fontSize: 30,
                fill: '#64748b',
                selectable: false,
                evented: false,
                excludeFromExport: true,
                linkedFrameId: frameId
            });

            rect.frameLabel = label;

            if (config.width > 1000) {
                rect.scale(0.5); 
                label.set({ top: rect.top - 50 });
            }

            // Create corresponding folder in state
            state.folders.push({
                id: folderId,
                name: config.name,
                collapsed: false,
                isFolder: true,
                isFrameFolder: true,
                linkedFrameId: frameId
            });

            canvas.add(rect);
            canvas.add(label);
            canvas.sendToBack(rect);
            canvas.renderAll();
            updateLayersPanel();
            saveLocalState();
        }

        // ... [Image Handling and Drop logic same as before] ...

        // Safe Area Logic
        function updateSafeAreaPosition(frame) {
            if (!frame.safeArea) return;
            const margin = Math.min(frame.width * frame.scaleX, frame.height * frame.scaleY) * 0.05;
            frame.safeArea.set({
                left: frame.left + margin,
                top: frame.top + margin,
                width: (frame.width * frame.scaleX) - (margin * 2),
                height: (frame.height * frame.scaleY) - (margin * 2),
                scaleX: 1, 
                scaleY: 1,
                angle: frame.angle
            });
            frame.safeArea.setCoords();
        }

        function toggleSafeAreas(show) {
            const objects = canvas.getObjects();
            
            if (!show) {
                // Remove existing safe areas
                const overlays = objects.filter(o => o.isSafeArea);
                overlays.forEach(o => {
                    canvas.remove(o);
                    if (o.linkedFrameId) {
                         const frame = objects.find(f => f.id === o.linkedFrameId);
                         if (frame) delete frame.safeArea;
                    }
                });
            } else {
                // Add safe areas to all frames
                const frames = objects.filter(o => o.isFrame);
                frames.forEach(frame => {
                    if (!frame.id) frame.id = uuidv4();

                    const margin = Math.min(frame.width * frame.scaleX, frame.height * frame.scaleY) * 0.05; // 5% margin
                    
                    const safeRect = new fabric.Rect({
                        left: frame.left + margin,
                        top: frame.top + margin,
                        width: (frame.width * frame.scaleX) - (margin * 2),
                        height: (frame.height * frame.scaleY) - (margin * 2),
                        fill: 'transparent',
                        stroke: 'rgba(255, 0, 0, 0.5)',
                        strokeWidth: 2,
                        strokeDashArray: [10, 10],
                        selectable: false,
                        evented: false,
                        isSafeArea: true,
                        linkedFrameId: frame.id
                    });
                    
                    frame.safeArea = safeRect;
                    canvas.add(safeRect);
                });
            }
            canvas.renderAll();
        }

        function setTextAlign(align) {
             updateActiveObject('textAlign', align);
        }

        // Image Handling
        function triggerImageUpload() {
            document.getElementById('img-upload').click();
        }

        function handleImageUpload(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                fabric.Image.fromURL(e.target.result, function(img) {
                    img.set({
                        id: uuidv4(),
                        left: 200,
                        top: 200,
                        scaleX: 0.5,
                        scaleY: 0.5
                    });
                    canvas.add(img);
                    canvas.setActiveObject(img);
                });
            };
            reader.readAsDataURL(file);
            input.value = ''; // Reset
        }
        
        // Drag and Drop Logic
        const dropOverlay = document.getElementById('drop-overlay');
        
        // Prevent browser from opening files globally
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            window.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });

        window.addEventListener('dragenter', (e) => {
            if (e.dataTransfer.types.includes('Files')) {
                dropOverlay.style.display = 'flex';
            }
        });

        window.addEventListener('dragover', (e) => {
            if (e.dataTransfer.types.includes('Files')) {
                e.preventDefault();
                dropOverlay.style.display = 'flex'; // Ensure it stays visible during hover
            }
        });

        dropOverlay.addEventListener('dragleave', (e) => {
            e.preventDefault();
            // Only hide if we actually leave the overlay
            if (e.relatedTarget === null || !dropOverlay.contains(e.relatedTarget)) {
                dropOverlay.style.display = 'none';
            }
        });
        
        dropOverlay.addEventListener('drop', (e) => {
            dropOverlay.style.display = 'none';
            
            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                // Calculate world coordinates from screen coordinates
                const vpt = canvas.viewportTransform;
                const zoom = canvas.getZoom();
                const worldX = (e.clientX - vpt[4]) / zoom;
                const worldY = (e.clientY - vpt[5]) / zoom;

                files.forEach((file, index) => {
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = function(f) {
                            fabric.Image.fromURL(f.target.result, function(img) {
                                // Add a cascading offset for multiple files
                                const offset = index * 20;

                                img.set({
                                    id: uuidv4(), // Generate unique ID for EACH image
                                    left: worldX + (offset / zoom),
                                    top: worldY + (offset / zoom),
                                    originX: 'center',
                                    originY: 'center',
                                    scaleX: 0.5 / zoom,
                                    scaleY: 0.5 / zoom
                                });
                                canvas.add(img);
                                if (index === files.length - 1) {
                                    canvas.setActiveObject(img);
                                }
                                checkForClipping(img);
                                if (index === files.length - 1) {
                                    saveHistory();
                                    saveLocalState();
                                    updateLayersPanel();
                                }
                            });
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
        });

        // --- 6. LOGIC: INTERACTION & PROPERTIES ---

        const propBar = document.getElementById('prop-bar');
        const textProps = document.getElementById('text-props');
        const fillColor = document.getElementById('fill-color');
        const fontSizeInput = document.getElementById('font-size');
        const fontFamilySelect = document.getElementById('font-family');

        const frameProps = document.getElementById('frame-props');
        const cloneTargetSelect = document.getElementById('clone-target');
        const imageProps = document.getElementById('image-props');
        const imgWidthInput = document.getElementById('img-width');
        const imgHeightInput = document.getElementById('img-height');
        const imgRadiusInput = document.getElementById('img-radius');

        canvas.on('selection:created', (e) => {
            handleSelection(e);
            updateLayersPanel();
        });
        canvas.on('selection:updated', (e) => {
            handleSelection(e);
            updateLayersPanel();
        });
        canvas.on('selection:cleared', () => {
            propBar.classList.remove('visible');
            // Ensure all objects are interactive again
            canvas.getObjects().forEach(obj => {
                if (!obj.locked) obj.evented = true;
            });
            canvas.isLayerIsolated = false;
            updateLayersPanel();
        });

        function handleSelection(e) {
            const obj = e.selected[0];
            if (!obj) return;

            propBar.classList.add('visible');
            
            // Common
            fillColor.value = obj.fill || '#ffffff';
            
            // Update lock button state
            const lockBtn = document.getElementById('ratio-lock-btn');
            // Check if uniformScaling is explicitly false (unlocked)
            if (obj.uniformScaling === false) {
                 lockBtn.innerHTML = '<i class="fa-solid fa-lock-open"></i>';
            } else {
                 lockBtn.innerHTML = '<i class="fa-solid fa-lock"></i>';
            }

            // Frame Specific
            if (obj.isFrame) {
                frameProps.style.display = 'flex';
                cloneTargetSelect.value = ""; // Reset selection
            } else {
                frameProps.style.display = 'none';
            }

            // Image Specific
            if (obj.type === 'image') {
                imageProps.style.display = 'flex';
                imgWidthInput.value = Math.round(obj.width * obj.scaleX);
                imgHeightInput.value = Math.round(obj.height * obj.scaleY);
                imgRadiusInput.value = obj.borderRadius || 0;
            } else {
                imageProps.style.display = 'none';
            }

            // Text Specific
            if (obj.type === 'textbox' || obj.type === 'text' || obj.type === 'i-text') {
                textProps.style.display = 'flex';
                fontSizeInput.value = obj.fontSize;
                fontFamilySelect.value = obj.fontFamily;
            } else {
                textProps.style.display = 'none';
            }
        }

        function updateImageProp(prop, value) {
            const obj = canvas.getActiveObject();
            if (!obj || obj.type !== 'image') return;

            value = parseInt(value);
            if (isNaN(value)) return;

            if (prop === 'width') {
                const newScaleX = value / obj.width;
                if (obj.uniformScaling) {
                    obj.scale(newScaleX);
                    imgHeightInput.value = Math.round(obj.height * obj.scaleY);
                } else {
                    obj.set('scaleX', newScaleX);
                }
            } else if (prop === 'height') {
                const newScaleY = value / obj.height;
                if (obj.uniformScaling) {
                    obj.scale(newScaleY);
                    imgWidthInput.value = Math.round(obj.width * obj.scaleX);
                } else {
                    obj.set('scaleY', newScaleY);
                }
            } else if (prop === 'radius') {
                obj.borderRadius = value;
                applyImageRadius(obj, value);
            }

            obj.setCoords();
            canvas.renderAll();
            saveHistory();
            saveLocalState();
        }

        function applyImageRadius(obj, radius) {
            if (radius > 0) {
                const clipPath = new fabric.Rect({
                    width: obj.width,
                    height: obj.height,
                    rx: radius / obj.scaleX,
                    ry: radius / obj.scaleY,
                    originX: 'center',
                    originY: 'center'
                });
                obj.set('clipPath', clipPath);
            } else {
                obj.set('clipPath', null);
            }
        }

        // Smart Clone Logic
        function cloneFrameTo(targetKey) {
            if (!targetKey) return;
            
            const originalFrame = canvas.getActiveObject();
            if (!originalFrame || !originalFrame.isFrame) return;

            const targetConfig = FRAMES[targetKey];
            if (!targetConfig) return;

            // 1. Create New Frame
            // Offset it by some amount so it doesn't overlap perfectly
            const newFrameLeft = originalFrame.left + originalFrame.width + 100;
            const newFrameTop = originalFrame.top;

            const newFrame = new fabric.Rect({
                left: newFrameLeft,
                top: newFrameTop,
                width: targetConfig.width,
                height: targetConfig.height,
                fill: originalFrame.fill, // Copy bg color
                stroke: '#cbd5e1',
                strokeWidth: 2,
                shadow: '0 10px 20px rgba(0,0,0,0.1)',
                objectCaching: false,
                isFrame: true,
                deviceName: targetConfig.name
            });

            // Label for new frame
            const newLabel = new fabric.Text(targetConfig.name, {
                left: newFrameLeft,
                top: newFrameTop - 40,
                fontSize: 30,
                fill: '#64748b',
                selectable: false
            });
            
            // 2. Find objects "inside" or overlapping the original frame
            const objects = canvas.getObjects();
            const objectsToClone = [];

            objects.forEach(obj => {
                if (obj === originalFrame || obj.text === originalFrame.deviceName) return; // Skip self and label
                if (obj.selectable === false) return; // Skip non-interactive

                // Simple collision detection or checking if center is inside
                if (obj.intersectsWithObject(originalFrame) || originalFrame.containsPoint(obj.getCenterPoint())) {
                    objectsToClone.push(obj);
                }
            });

            canvas.add(newFrame);
            canvas.add(newLabel);
            canvas.sendToBack(newFrame);

            // 3. Clone and Reposition Content
            if (objectsToClone.length > 0) {
                objectsToClone.forEach(obj => {
                    obj.clone(function(cloned) {
                        // Calculate relative position from original center
                        const origCenter = originalFrame.getCenterPoint();
                        const objCenter = obj.getCenterPoint();
                        const diffX = objCenter.x - origCenter.x;
                        const diffY = objCenter.y - origCenter.y;

                        // Place on new frame center + diff
                        // Note: This preserves absolute offset from center. 
                        // For better "responsive" design, we might want percentage based, 
                        // but centering is a safe default for "Smart Clone".
                        
                        const newCenterX = newFrameLeft + (targetConfig.width / 2) + diffX;
                        const newCenterY = newFrameTop + (targetConfig.height / 2) + diffY;

                        cloned.set({
                            left: newCenterX - (cloned.width * cloned.scaleX) / 2, // approximate origin correction
                            top: newCenterY - (cloned.height * cloned.scaleY) / 2,
                            textId: obj.textId // CRITICAL: Keep same ID for translation sync!
                        });

                        // Adjust origin if needed (Fabric defaults to Top/Left usually)
                        // More precise:
                        cloned.setPositionByOrigin(
                            new fabric.Point(newCenterX, newCenterY), 
                            'center', 
                            'center'
                        );

                        canvas.add(cloned);
                    });
                });
            }

            canvas.renderAll();
            showToast(`Sklonowano do ${targetConfig.name}`);
            
            // Reset selector
            cloneTargetSelect.value = "";
        }

        function updateActiveObject(prop, value) {
            const obj = canvas.getActiveObject();
            if (obj) {
                obj.set(prop, value);
                canvas.requestRenderAll();
                saveHistory();
                saveLocalState();
            }
        }

        // Global Background
        function setGlobalBackground(color) {
            const objects = canvas.getObjects();
            let count = 0;
            objects.forEach(obj => {
                if (obj.isFrame) {
                    obj.set('fill', color);
                    count++;
                }
            });
            canvas.renderAll();
            showToast(`Zaktualizowano tÅ‚o dla ${count} ekranÃ³w`);
            saveHistory();
            saveLocalState();
        }

        // Aspect Ratio Toggle
        function toggleAspectRatio() {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            
            // Fabric uses 'uniformScaling' property (true = locked ratio, false = free)
            // Or 'lockUniScaling' depending on version/config.
            // Let's toggle both to be safe and update UI.
            
            const current = obj.uniformScaling;
            obj.set('uniformScaling', !current);
            
            // Update button icon
            const btn = document.getElementById('ratio-lock-btn');
            if (obj.uniformScaling) {
                btn.innerHTML = '<i class="fa-solid fa-lock"></i>';
                showToast("Proporcje: Zablokowane");
            } else {
                btn.innerHTML = '<i class="fa-solid fa-lock-open"></i>';
                showToast("Proporcje: Odblokowane");
            }
            
            canvas.requestRenderAll();
        }

        function toggleBold() {
            const obj = canvas.getActiveObject();
            if (obj && (obj.type === 'textbox' || obj.type === 'text')) {
                obj.set('fontWeight', obj.fontWeight === 'bold' ? 'normal' : 'bold');
                canvas.requestRenderAll();
            }
        }

        function toggleItalic() {
            const obj = canvas.getActiveObject();
            if (obj && (obj.type === 'textbox' || obj.type === 'text')) {
                obj.set('fontStyle', obj.fontStyle === 'italic' ? 'normal' : 'italic');
                canvas.requestRenderAll();
            }
        }
        
        function bringToFront() {
            const obj = canvas.getActiveObject();
            if(obj) { canvas.bringToFront(obj); canvas.discardActiveObject(); canvas.renderAll(); }
        }
        
        function sendToBack() {
            const obj = canvas.getActiveObject();
            if(obj) { canvas.sendToBack(obj); canvas.discardActiveObject(); canvas.renderAll(); }
        }

        function deleteActive() {
            const activeObj = canvas.getActiveObject();
            if (!activeObj) return;

            const objectsToDelete = activeObj.type === 'activeSelection' ? activeObj.getObjects() : [activeObj];

            objectsToDelete.forEach(obj => {
                // Remove from translations state if it's a text object
                if (obj.id && (obj.type === 'textbox' || obj.type === 'text' || obj.type === 'i-text')) {
                    Object.keys(state.translations).forEach(lang => {
                        delete state.translations[lang][obj.id];
                    });
                }

                // If it's a frame, remove its label and corresponding folder
                if (obj.isFrame) {
                    if (obj.frameLabel) canvas.remove(obj.frameLabel);
                    if (obj.folderId) {
                        state.folders = state.folders.filter(f => f.id !== obj.folderId);
                    }
                }

                // Remove from canvas
                canvas.remove(obj);
            });

            canvas.discardActiveObject();
            canvas.renderAll();
            updateJSONEditor();
            updateLayersPanel();
            saveLocalState();
        }

        // --- 7. LOGIC: TRANSLATION SYSTEM ---

        // Listener for text editing on canvas
        canvas.on('text:changed', function(e) {
            const obj = e.target;
            if (obj.id) {
                // Update state
                state.translations[state.currentLang][obj.id] = obj.text;
                updateJSONEditor();
                saveHistory();
                debouncedSave();
            }
        });

        // Language Switcher
        document.getElementById('lang-switcher').addEventListener('change', function(e) {
            const newLang = e.target.value;
            switchLanguage(newLang);
        });

        function switchLanguage(lang) {
            state.currentLang = lang;
            
            // Iterate all objects and update text
            const objects = canvas.getObjects();
            objects.forEach(obj => {
                if (obj.id) {
                    const translation = state.translations[lang]?.[obj.id] || state.translations['en-US']?.[obj.id];
                    if (translation !== undefined) {
                        obj.set('text', translation);
                    }
                }
            });
            
            canvas.renderAll();
            updateJSONEditor();
            showToast(`JÄ™zyk zmieniony na: ${lang}`);
            saveLocalState();
        }

        // JSON Drawer Logic
        const drawer = document.getElementById('json-drawer');
        const jsonEditor = document.getElementById('json-editor');

        function toggleDrawer() {
            drawer.classList.toggle('open');
            if (drawer.classList.contains('open')) {
                updateJSONEditor();
            }
        }

        function updateJSONEditor() {
            // We show the FULL translation object or just the current lang?
            // The req says "all texts with translations". Let's show full object.
            jsonEditor.value = JSON.stringify(state.translations, null, 2);
        }

        function applyJSON() {
            try {
                const newData = JSON.parse(jsonEditor.value);
                
                // Dynamically learn languages from the new JSON
                state.translations = newData;
                updateLangSwitcher();
                
                // Re-apply text for current lang
                switchLanguage(state.currentLang);
                showToast("JSON zaÅ‚adowany pomyÅ›lnie");
                saveLocalState(); // Save the new structure
            } catch (e) {
                alert("BÅ‚Ä…d JSON: " + e.message);
            }
        }

        function updateLangSwitcher() {
            const switcher = document.getElementById('lang-switcher');
            const currentVal = switcher.value;
            switcher.innerHTML = ''; // Clear existing options
            
            const languageCodes = Object.keys(state.translations);

            // Add new options
            languageCodes.forEach(code => {
                const option = document.createElement('option');
                option.value = code;
                
                // Simple flag emoji generator (may not cover all codes)
                let flag = 'ðŸ³ï¸';
                try {
                    if (code.includes('-')) {
                        const countryCode = code.split('-')[1].toUpperCase();
                        flag = countryCode.split('').map(char => String.fromCodePoint(char.charCodeAt(0) + 127397)).join('');
                    }
                } catch(e) { /* ignore emoji errors */ }
                
                option.textContent = `${flag} ${code}`;
                switcher.appendChild(option);
            });

            // Restore selection
            if (languageCodes.includes(currentVal)) {
                switcher.value = currentVal;
            } else if (languageCodes.length > 0) {
                switcher.value = languageCodes[0];
                switchLanguage(languageCodes[0]);
            }
        }

        function copyJSON() {
            jsonEditor.select();
            document.execCommand('copy');
            showToast("Skopiowano do schowka");
        }

        // --- 8. EXPORT LOGIC ---

        // Helper function for low-level binary conversion
        function base64ToUint8Array(base64) {
            var binary_string = window.atob(base64);
            var len = binary_string.length;
            var bytes = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes;
        }

        async function exportScreenshots() {
            showToast("Generowanie zrzutÃ³w... ProszÄ™ czekaÄ‡.");
            const zip = new JSZip();
            
            const initialLang = state.currentLang;
            const initialVpt = [...canvas.viewportTransform];
            const initialZoom = canvas.getZoom();

            const frames = canvas.getObjects().filter(o => o.isFrame);
            
            if (frames.length === 0) {
                alert("Nie dodano Å¼adnych ramek (ekranÃ³w).");
                return;
            }

            // Reset view
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            canvas.setZoom(1);

            const languages = Object.keys(state.translations);

            try {
                for (let lang of languages) {
                    switchLanguage(lang);
                    canvas.renderAll();
                    await new Promise(r => setTimeout(r, 50));

                    const langFolder = zip.folder(lang);

                    for (let i = 0; i < frames.length; i++) {
                        const frame = frames[i];
                        
                        const wasLabelVisible = frame.frameLabel ? frame.frameLabel.visible : true;
                        const wasSafeAreaVisible = frame.safeArea ? frame.safeArea.visible : false;
                        
                        if (frame.frameLabel) frame.frameLabel.visible = false;
                        if (frame.safeArea) frame.safeArea.visible = false;
                        
                        const dataURL = canvas.toDataURL({
                            left: frame.left,
                            top: frame.top,
                            width: frame.width * frame.scaleX,
                            height: frame.height * frame.scaleY,
                            multiplier: 1,
                            format: 'png',
                            quality: 1
                        });
                        
                        // Restore visibility
                        if (frame.frameLabel) frame.frameLabel.visible = wasLabelVisible;
                        if (frame.safeArea) frame.safeArea.visible = wasSafeAreaVisible;

                        // LOW-LEVEL BINARY CONVERSION
                        // Strip metadata prefix
                        const base64Data = dataURL.replace(/^data:image\/png;base64,/, "");
                        
                        // Convert directly to Byte Array
                        const byteData = base64ToUint8Array(base64Data);

                        // Use generic SAFE name to rule out filesystem issues
                        // We append the unique frame ID to avoid collisions
                        const cleanName = frame.deviceName.replace(/[^a-zA-Z0-9]/g, '');
                        const fileName = `Screen_${cleanName}_${i+1}.png`;
                        
                        // Add raw bytes to ZIP
                        langFolder.file(fileName, byteData);
                    }
                }
            } finally {
                switchLanguage(initialLang);
                canvas.setViewportTransform(initialVpt);
                canvas.setZoom(initialZoom);
                canvas.requestRenderAll();
            }

            // Generate ZIP with NO COMPRESSION (STORE)
            // This is faster and less likely to be flagged by heuristics
            zip.generateAsync({
                type: "blob", 
                mimeType: "application/zip",
                compression: "STORE" 
            })
            .then(function(content) {
                saveAs(content, "ShotLingo_export.zip");
                showToast("Gotowe! Pobieranie...");
            });
        }

        // --- UTILS ---
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 3000);
        }

        // Initial call
        updateJSONEditor();
        setTimeout(updateLayersPanel, 500);

        // --- 9. LAYERS PANEL LOGIC ---
        state.folders = []; // Store folder metadata {id, name, collapsed}
        let draggedLayerId = null;

        function createNewFolder() {
            const folderName = prompt("Nazwa folderu:", "Nowa grupa");
            if (!folderName) return;
            
            const folder = {
                id: 'folder_' + uuidv4(),
                name: folderName,
                collapsed: false,
                isFolder: true
            };
            
            state.folders.push(folder);
            updateLayersPanel();
            saveLocalState();
        }

        function updateLayersPanel() {
            const layersList = document.getElementById('layers-list');
            if (!layersList) return;

            const allObjects = canvas.getObjects().filter(obj => 
                !obj.excludeFromExport && !obj.isSafeArea && !(obj.linkedFrameId && !obj.isFrame)
            );
            
            const objects = allObjects.slice().reverse();
            const activeObject = canvas.getActiveObject();
            
            layersList.innerHTML = '';

            const renderItem = (obj, isNested = false) => {
                const item = document.createElement('div');
                
                // Check if selected (single or as part of multiple selection)
                let isActive = activeObject === obj;
                if (activeObject && activeObject.type === 'activeSelection') {
                    isActive = activeObject.contains(obj);
                }

                // Added 'moving' class if the object is currently being transformed
                const isMoving = isActive && (obj.isMoving || obj.isScaling || obj.isRotating);
                item.className = `layer-item ${isActive ? 'active' : ''} ${isMoving ? 'moving' : ''} ${obj.locked ? 'is-locked' : ''} ${isNested ? 'nested' : ''}`;
                item.draggable = true;
                item.dataset.id = obj.id;
                
                let icon = 'fa-shapes';
                let type = obj.type;
                
                let name = obj.customName || 'Element';

                if (obj.isFrame) {
                    icon = 'fa-mobile-screen';
                    if (!obj.customName) name = obj.deviceName || 'Ekran';
                    type = 'Frame';
                } else if (obj.type === 'textbox' || obj.type === 'text' || obj.type === 'i-text') {
                    icon = 'fa-font';
                    if (!obj.customName) name = obj.text ? (obj.text.substring(0, 15) + (obj.text.length > 15 ? '...' : '')) : 'Tekst';
                } else if (obj.type === 'image') {
                    icon = 'fa-image';
                    if (!obj.customName) name = 'Obraz';
                }

                item.innerHTML = `
                    <i class="fa-solid ${icon}" style="width: 20px; text-align: center; color: #64748b;"></i>
                    <div class="layer-info">
                        <div class="layer-name">${name}</div>
                        <div class="layer-type">${type}</div>
                    </div>
                    <div class="layer-actions">
                        <button class="layer-action-btn lock-btn ${obj.locked ? 'locked' : ''}" title="Zablokuj/Odblokuj">
                            <i class="fa-solid ${obj.locked ? 'fa-lock' : 'fa-lock-open'} "></i>
                        </button>
                        <button class="layer-action-btn rename-btn" title="ZmieÅ„ nazwÄ™">
                            <i class="fa-solid fa-pencil" style="font-size: 0.7rem;"></i>
                        </button>
                        <button class="layer-action-btn vis-btn ${!obj.visible ? 'hidden' : ''}" title="WidocznoÅ›Ä‡">
                            <i class="fa-solid ${obj.visible ? 'fa-eye' : 'fa-eye-slash'} "></i>
                        </button>
                    </div>
                `;

                // Rename action
                const renameBtn = item.querySelector('.rename-btn');
                renameBtn.onclick = (e) => {
                    e.stopPropagation();
                    const nameEl = item.querySelector('.layer-name');
                    startRenaming(nameEl, (newName) => {
                        obj.customName = newName;
                        updateLayersPanel();
                        saveLocalState();
                    });
                };

                // Lock action
                const lockBtn = item.querySelector('.lock-btn');
                lockBtn.onclick = (e) => { e.stopPropagation(); toggleObjectLock(obj); };

                // Drag Events for Layer Reordering and Folder Assignment
                item.ondragstart = (e) => {
                    draggedLayerId = obj.id;
                    item.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', draggedLayerId);
                    e.dataTransfer.effectAllowed = 'move';
                };
                item.ondragend = () => {
                    item.classList.remove('dragging');
                    document.querySelectorAll('.layer-item').forEach(el => el.classList.remove('drag-over'));
                };
                item.ondragover = (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    item.classList.add('drag-over');
                };
                item.ondragleave = () => item.classList.remove('drag-over');
                item.ondrop = (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    handleLayerDrop(draggedLayerId, obj, e);
                };

                // Visibility toggle click
                const visBtn = item.querySelector('.vis-btn');
                visBtn.onclick = (e) => { e.stopPropagation(); toggleLayerVisibility(obj); };
                // Selection click
                item.onclick = (e) => {
                    const isMulti = e.ctrlKey || e.metaKey;
                    const activeObject = canvas.getActiveObject();
                    
                    if (isMulti) {
                        // Multi-select stays in direct mode
                        handleMultiSelect(obj, activeObject);
                    } else {
                        // Single Selection from Layers Panel -> TRIGGER ISOLATION
                        canvas.getObjects().forEach(other => {
                            if (other !== obj && !other.excludeFromExport) {
                                other.evented = false; // Disable others
                            } else {
                                other.evented = true;
                            }
                        });
                        canvas.isLayerIsolated = true;
                        canvas.setActiveObject(obj);
                    }
                    
                    canvas.renderAll();
                    updateLayersPanel();
                };

                return item;
            };

            state.folders.forEach(folder => {
                const fItem = document.createElement('div');
                fItem.className = 'layer-item folder';
                fItem.draggable = true; // Folders can also be reordered
                const folderIcon = folder.isFrameFolder ? 'fa-mobile-screen-button' : 'fa-folder-open';
                const folderColor = folder.isFrameFolder ? 'var(--primary-color)' : '#f59e0b';

                fItem.innerHTML = `
                    <div class="folder-toggle" onclick="toggleFolder('${folder.id}', event)">
                        <i class="fa-solid ${folder.collapsed ? 'fa-caret-right' : 'fa-caret-down'}"></i>
                    </div>
                    <i class="fa-solid ${folderIcon}" style="color: ${folderColor}; width: 20px; text-align: center;"></i>
                    <div class="layer-info">
                        <div class="layer-name">${folder.name}</div>
                    </div>
                    <div class="layer-actions">
                        <button class="layer-action-btn lock-btn ${folder.locked ? 'locked' : ''}" title="Zablokuj grupÄ™"><i class="fa-solid ${folder.locked ? 'fa-lock' : 'fa-lock-open'}"></i></button>
                        <button class="layer-action-btn rename-btn" title="ZmieÅ„ nazwÄ™"><i class="fa-solid fa-pencil" style="font-size: 0.7rem;"></i></button>
                        <button class="layer-action-btn" onclick="deleteFolder('${folder.id}', event)"><i class="fa-solid fa-trash"></i></button>
                    </div>
                `;
                
                // Lock Folder
                const lockBtn = fItem.querySelector('.lock-btn');
                lockBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleFolderLock(folder);
                };
                
                // Rename Folder action
                const renameBtn = fItem.querySelector('.rename-btn');
                renameBtn.onclick = (e) => {
                    e.stopPropagation();
                    const nameEl = fItem.querySelector('.layer-name');
                    startRenaming(nameEl, (newName) => {
                        folder.name = newName;
                        updateLayersPanel();
                        saveLocalState();
                    });
                };

                // Folder Drag Events (as a drop target for grouping and a source for folder reordering)
                fItem.ondragstart = (e) => {
                    draggedLayerId = folder.id;
                    fItem.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', folder.id);
                };
                fItem.ondragend = () => fItem.classList.remove('dragging');
                
                fItem.ondragover = (e) => { 
                    e.preventDefault(); 
                    fItem.classList.add('drag-over'); 
                };
                fItem.ondragleave = () => fItem.classList.remove('drag-over');
                fItem.ondrop = (e) => {
                    e.preventDefault();
                    fItem.classList.remove('drag-over');
                    
                    if (draggedLayerId && draggedLayerId.startsWith('folder_')) {
                        // Reorder folders if needed (future expansion)
                    } else {
                        // Assign item to this folder
                        assignToFolder(draggedLayerId, folder.id);
                    }
                };

                layersList.appendChild(fItem);

                if (!folder.collapsed) {
                    objects.filter(o => o.folderId === folder.id).forEach(obj => {
                        layersList.appendChild(renderItem(obj, true));
                    });
                }
            });

            objects.filter(o => !o.folderId).forEach(obj => {
                layersList.appendChild(renderItem(obj));
            });
            
            if (objects.length === 0 && state.folders.length === 0) {
                layersList.innerHTML = '<div style="padding: 20px; text-align: center; color: #94a3b8; font-size: 0.8rem;">Brak warstw</div>';
            }
        }

        function startRenaming(el, onComplete) {
            const currentName = el.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'layer-name-input';
            input.value = currentName;
            
            // Prevent input interactions from triggering parent layer drag/click
            input.addEventListener('click', (e) => e.stopPropagation());
            input.addEventListener('mousedown', (e) => e.stopPropagation());
            
            el.innerHTML = '';
            el.appendChild(input);
            input.focus();
            input.select();

            const finish = () => {
                if (!input.parentNode) return; // Already finished
                const newName = input.value.trim() || currentName;
                onComplete(newName);
            };

            input.addEventListener('blur', finish);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finish();
                }
                if (e.key === 'Escape') {
                    e.preventDefault();
                    input.removeEventListener('blur', finish); // Cancel finish
                    el.textContent = currentName;
                }
            });
        }

        function toggleFolder(id, event) {
            event.stopPropagation();
            const folder = state.folders.find(f => f.id === id);
            if (folder) {
                folder.collapsed = !folder.collapsed;
                updateLayersPanel();
            }
        }

        function deleteFolder(id, event) {
            event.stopPropagation();
            const folder = state.folders.find(f => f.id === id);
            if (!folder) return;

            const isFrame = folder.isFrameFolder;
            const confirmMsg = isFrame ? 
                "UsunÄ…Ä‡ ten ekran wraz z zawartoÅ›ciÄ…? (Elementy wewnÄ…trz zostanÄ… wyciÄ…gniÄ™te)" : 
                "UsunÄ…Ä‡ folder? Elementy zostanÄ… wyciÄ…gniÄ™te na zewnÄ…trz.";

            if (!confirm(confirmMsg)) return;
            
            const objects = canvas.getObjects();
            
            // If it's a frame folder, remove the physical frame and its label
            if (isFrame && folder.linkedFrameId) {
                const frameObj = objects.find(o => o.id === folder.linkedFrameId);
                if (frameObj) {
                    if (frameObj.frameLabel) canvas.remove(frameObj.frameLabel);
                    if (frameObj.safeArea) canvas.remove(frameObj.safeArea);
                    canvas.remove(frameObj);
                }
            }

            objects.forEach(obj => {
                if (obj.folderId === id) delete obj.folderId;
            });
            
            state.folders = state.folders.filter(f => f.id !== id);
            canvas.renderAll();
            updateLayersPanel();
            saveLocalState();
        }

        function handleRootDrop(e) {
            // Only trigger if dropped directly on the list container, not its children
            if (e.target.id !== 'layers-list') return;
            
            e.preventDefault();
            const objects = canvas.getObjects();
            const draggedObj = objects.find(o => o.id === draggedLayerId);
            
            if (draggedObj) {
                // Move to top of canvas (highest index) and remove from folder
                draggedObj.moveTo(objects.length - 1);
                delete draggedObj.folderId;
                
                canvas.renderAll();
                updateLayersPanel();
                saveHistory();
                saveLocalState();
            }
        }

        function assignToFolder(objId, folderId) {
            const obj = canvas.getObjects().find(o => o.id === objId);
            if (obj) {
                obj.folderId = folderId;
                updateLayersPanel();
                saveLocalState();
            }
        }

        function handleLayerDrop(draggedId, targetObj, event) {
            const allObjects = canvas.getObjects();
            const draggedObj = allObjects.find(o => o.id === draggedId);
            
            if (!draggedObj || draggedObj === targetObj) return;

            // Fabric.js: higher index = on top
            // Our UI: top of list = higher index (on top)
            
            const targetIndex = allObjects.indexOf(targetObj);
            
            // Check if we dropped on the top or bottom half of the target item
            const rect = event.currentTarget.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const isTopHalf = event.clientY < midpoint;

            // If we drop on top half, we want it to be ABOVE the target (higher index)
            // If we drop on bottom half, we want it to be BELOW the target (lower index)
            let newIndex = isTopHalf ? targetIndex + 1 : targetIndex;

            // If the dragged object was originally BELOW the target and we move it ABOVE, 
            // the indices shift. Fabric's moveTo handles the absolute position in the array.
            
            draggedObj.moveTo(newIndex);
            
            // Also inherit folder if target is in folder
            draggedObj.folderId = targetObj.folderId;

            canvas.renderAll();
            updateLayersPanel();
            saveHistory();
            saveLocalState();
        }

        function toggleLayerVisibility(obj) {
            if (!obj) return;
            obj.visible = !obj.visible;
            if (obj.isFrame) {
                if (obj.frameLabel) obj.frameLabel.visible = obj.visible;
                if (obj.safeArea) obj.safeArea.visible = obj.visible;
            }
            canvas.renderAll();
            updateLayersPanel();
            saveLocalState();
        }

        // Initialize layers panel
        setTimeout(updateLayersPanel, 500);

        // --- 10. MINIMAP LOGIC ---
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimapContainer = document.getElementById('minimap-container');
        
        function resizeMinimap() {
             const rect = minimapContainer.getBoundingClientRect();
             minimapCanvas.width = rect.width;
             minimapCanvas.height = rect.height;
             requestAnimationFrame(updateMinimap);
        }
        window.addEventListener('resize', resizeMinimap);
        
        // Initial resize delay to ensure DOM is ready
        setTimeout(resizeMinimap, 100);

        function updateMinimap() {
            if (!minimapCtx) return;

            const width = minimapCanvas.width;
            const height = minimapCanvas.height;

            // Clear and set background
            minimapCtx.fillStyle = '#f1f5f9';
            minimapCtx.fillRect(0, 0, width, height);

            const objects = canvas.getObjects().filter(o => !o.excludeFromExport && !o.isSafeArea);
            
            // Current viewport in world coords
            const vpt = canvas.viewportTransform;
            const zoom = canvas.getZoom();
            const viewX = -vpt[4] / zoom;
            const viewY = -vpt[5] / zoom;
            const viewW = canvas.width / zoom;
            const viewH = canvas.height / zoom;

            // Calculate World Bounds (Objects + Viewport)
            let minX = viewX, minY = viewY, maxX = viewX + viewW, maxY = viewY + viewH;
            
            if (objects.length > 0) {
                objects.forEach(obj => {
                    const br = obj.getBoundingRect(true);
                    if (br.left < minX) minX = br.left;
                    if (br.top < minY) minY = br.top;
                    if (br.left + br.width > maxX) maxX = br.left + br.width;
                    if (br.top + br.height > maxY) maxY = br.top + br.height;
                });
            }

            // Add padding
            const padding = 300; 
            minX -= padding; minY -= padding; maxX += padding; maxY += padding;

            const worldWidth = maxX - minX;
            const worldHeight = maxY - minY;

            const minimapScale = Math.min(width / worldWidth, height / worldHeight);
            const offsetX = (width - (worldWidth * minimapScale)) / 2;
            const offsetY = (height - (worldHeight * minimapScale)) / 2;

            // Data for interaction
            minimapCanvas.dataset.scale = minimapScale;
            minimapCanvas.dataset.minX = minX;
            minimapCanvas.dataset.minY = minY;
            minimapCanvas.dataset.offsetX = offsetX;
            minimapCanvas.dataset.offsetY = offsetY;

            // Draw Objects
            objects.forEach(obj => {
                const br = obj.getBoundingRect(true);
                const x = offsetX + (br.left - minX) * minimapScale;
                const y = offsetY + (br.top - minY) * minimapScale;
                const w = br.width * minimapScale;
                const h = br.height * minimapScale;
                
                minimapCtx.fillStyle = obj.isFrame ? '#94a3b8' : '#cbd5e1';
                minimapCtx.fillRect(x, y, w, h);
            });
            
            // Draw Viewport Indicator
            const mapVx = offsetX + (viewX - minX) * minimapScale;
            const mapVy = offsetY + (viewY - minY) * minimapScale;
            const mapVw = viewW * minimapScale;
            const mapVh = viewH * minimapScale;
            
            // Viewport Shadow
            minimapCtx.fillStyle = 'rgba(0,0,0,0.1)';
            minimapCtx.fillRect(0, 0, width, mapVy); // Top
            minimapCtx.fillRect(0, mapVy + mapVh, width, height - (mapVy + mapVh)); // Bottom
            minimapCtx.fillRect(0, mapVy, mapVx, mapVh); // Left
            minimapCtx.fillRect(mapVx + mapVw, mapVy, width - (mapVx + mapVw), mapVh); // Right

            // Viewport Stroke
            minimapCtx.strokeStyle = '#3b82f6';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(mapVx, mapVy, mapVw, mapVh);
        }
        
        canvas.on('after:render', updateMinimap);
        
        // Minimap Interaction Handlers
        let isNavigatingMinimap = false;
        
        function moveViewportTo(mx, my) {
            const scale = parseFloat(minimapCanvas.dataset.scale);
            const minX = parseFloat(minimapCanvas.dataset.minX);
            const minY = parseFloat(minimapCanvas.dataset.minY);
            const offsetX = parseFloat(minimapCanvas.dataset.offsetX);
            const offsetY = parseFloat(minimapCanvas.dataset.offsetY);
            
            if (!scale) return;

            const worldX = ((mx - offsetX) / scale) + minX;
            const worldY = ((my - offsetY) / scale) + minY;
            const zoom = canvas.getZoom();
            
            // Position world target in screen center
            canvas.viewportTransform[4] = (canvas.width / 2) - (worldX * zoom);
            canvas.viewportTransform[5] = (canvas.height / 2) - (worldY * zoom);
            
            canvas.requestRenderAll();
        }
        
        minimapCanvas.addEventListener('mousedown', (e) => {
            isNavigatingMinimap = true;
            moveViewportTo(e.offsetX, e.offsetY);
        });
        
        window.addEventListener('mousemove', (e) => {
            if (isNavigatingMinimap) {
                const rect = minimapCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                moveViewportTo(x, y);
            }
        });
        
        window.addEventListener('mouseup', () => {
            isNavigatingMinimap = false;
        });

        // --- 11. GEMINI AI TRANSLATION ---
        let geminiApiKey = localStorage.getItem('timo_gemini_key') || '';
        let currentGeminiModel = localStorage.getItem('timo_gemini_model') || 'gemini-1.5-flash';

        function checkGeminiAuth() {
            const container = document.getElementById('ai-model-container');
            if (geminiApiKey) {
                container.style.display = 'flex';
                fetchGeminiModels();
            } else {
                container.style.display = 'none';
            }
        }
        
        async function fetchGeminiModels() {
            const select = document.getElementById('gemini-model-select');
            try {
                // Fetch models from Google
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${geminiApiKey}`);
                const data = await response.json();
                
                if (data.models) {
                    select.innerHTML = ''; // Clear defaults
                    
                    // Filter for models that support generateContent
                    const capableModels = data.models.filter(m => 
                        m.supportedGenerationMethods && 
                        m.supportedGenerationMethods.includes('generateContent')
                    );

                    // Sort to put 'flash' and 'pro' at the top
                    capableModels.sort((a, b) => {
                        const nameA = a.name.toLowerCase();
                        const nameB = b.name.toLowerCase();
                        if (nameA.includes('flash') && !nameB.includes('flash')) return -1;
                        if (nameA.includes('pro') && !nameB.includes('pro')) return -1;
                        return 0;
                    });

                    capableModels.forEach(model => {
                        const option = document.createElement('option');
                        // Model name comes like "models/gemini-1.5-flash"
                        const cleanName = model.name.replace('models/', '');
                        option.value = cleanName;
                        option.text = model.displayName || cleanName;
                        select.appendChild(option);
                    });

                    // Restore selection or default
                    if (currentGeminiModel) {
                        select.value = currentGeminiModel;
                    }
                }
            } catch (e) {
                console.error("Failed to fetch models", e);
                // Fallback: keep the default hardcoded option in HTML if fetch fails
            }
        }

        function saveGeminiModel(model) {
            currentGeminiModel = model;
            localStorage.setItem('timo_gemini_model', model);
        }

        // Init check
        setTimeout(checkGeminiAuth, 500);

        function setGeminiKey() {
            const newKey = prompt("WprowadÅº swÃ³j klucz API Google Gemini:", geminiApiKey);
            if (newKey !== null) {
                geminiApiKey = newKey;
                localStorage.setItem('timo_gemini_key', newKey);
                checkGeminiAuth();
                showToast(newKey ? "Klucz zapisany" : "Klucz usuniÄ™ty");
            }
        }

        async function translateWithGemini() {
            if (!geminiApiKey) {
                alert("Najpierw ustaw klucz API!");
                return;
            }

            const btn = document.getElementById('ai-translate-btn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> TÅ‚umaczenie...';
            btn.disabled = true;

            // Get selected model
            const select = document.getElementById('gemini-model-select');
            const modelName = select.value || 'gemini-1.5-flash';

            try {
                // Prepare the prompt
                const systemPrompt = `
You are an expert app localization AI. 
I will provide a JSON object containing translation keys. 
The structure is: { "LanguageCode": { "ElementID": "TextString" } }.

Your task:
1. Analyze the 'en-US' (English) source texts.
2. Translate these texts into ALL other target languages present in the JSON object (e.g., 'pl-PL', 'de-DE', 'fr-FR', etc.).
3. If an ElementID exists in 'en-US' but not in a target language, CREATE it in the target language and provide the translation.
4. Overwrite existing values in target languages with the new translations.
5. Keep 'en-US' unchanged.
6. STRICTLY preserve the JSON structure and keys (ElementIDs).
7. Return ONLY the valid, raw JSON string. Do not use Markdown code blocks (like \`\`\`json). Do not add explanations.

Input JSON:
${JSON.stringify(state.translations)}
`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${geminiApiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{ text: systemPrompt }]
                        }]
                    })
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                // Extract and parse JSON
                let rawText = data.candidates[0].content.parts[0].text;
                // Clean up potential markdown formatting if the model disobeys
                rawText = rawText.replace(/```json/g, '').replace(/```/g, '').trim();
                
                const newTranslations = JSON.parse(rawText);

                // Validate structure roughly
                if (!newTranslations['en-US']) throw new Error("Invalid AI response structure");

                // Apply changes
                state.translations = newTranslations;
                switchLanguage(state.currentLang); // Refresh view
                updateJSONEditor();
                saveLocalState();
                
                showToast("âœ¨ TÅ‚umaczenie zakoÅ„czone sukcesem!");

            } catch (e) {
                console.error("Gemini Error:", e);
                alert("BÅ‚Ä…d AI: " + e.message);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

    </script>
</body>
</html>
