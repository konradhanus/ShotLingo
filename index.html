<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Timo - App Store Screenshot Builder</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        :root {
            --primary-color: #3b82f6;
            --bg-dark: #1e293b;
            --bg-panel: rgba(255, 255, 255, 0.95);
            --text-main: #334155;
            --border-radius: 12px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f1f5f9;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through to canvas */
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        .ui-faded {
            opacity: 0.2;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        /* Top Bar */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: var(--shadow);
            z-index: 100;
            transition: opacity 0.3s;
        }

        .logo { font-weight: bold; font-size: 1.2rem; color: var(--primary-color); display: flex; align-items: center; gap: 10px; }
        
        .actions { display: flex; gap: 10px; align-items: center; }

        .btn {
            background: white;
            border: 1px solid #cbd5e1;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            color: var(--text-main);
        }
        
        .btn:hover { background: #f8fafc; border-color: var(--primary-color); }
        .btn.primary { background: var(--primary-color); color: white; border-color: var(--primary-color); }
        .btn.primary:hover { background: #2563eb; }

        /* Floating Toolbar (Left) */
        .toolbar {
            position: absolute;
            left: 20px;
            top: 80px;
            background: var(--bg-panel);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            padding: 10px;
            gap: 10px;
            z-index: 90;
            transition: opacity 0.3s;
        }

        .tool-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-main);
        }
        
        .tool-btn:hover { background: #f1f5f9; color: var(--primary-color); }
        .tool-btn.active { background: #e0f2fe; color: var(--primary-color); }

        /* JSON Drawer (Right) */
        .drawer {
            position: absolute;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: white;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .drawer.open { right: 0; }
        
        .drawer-header {
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .drawer-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        textarea.json-editor {
            width: 100%;
            flex: 1;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            resize: none;
            background: #f8fafc;
            color: #334155;
        }

        /* Language Switcher */
        .lang-select {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            background: white;
            cursor: pointer;
        }

        /* Property Bar (Bottom/Selected Context) */
        .property-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            padding: 10px 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: none; /* Hidden by default */
            gap: 15px;
            align-items: center;
            z-index: 95;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            max-width: 600px;
        }
        
        .property-bar.visible { display: flex; }

        .prop-group { display: flex; align-items: center; gap: 8px; border-right: 1px solid #e2e8f0; padding-right: 15px; }
        .prop-group:last-child { border-right: none; padding-right: 0; }

        input[type="color"] { width: 30px; height: 30px; border: none; cursor: pointer; background: none; }
        input[type="number"] { width: 60px; padding: 5px; border: 1px solid #cbd5e1; border-radius: 4px; }
        select { padding: 5px; border: 1px solid #cbd5e1; border-radius: 4px; }

        /* Notifications */
        .toast {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: #334155;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 300;
        }
        .toast.show { opacity: 1; }
        
        /* Mobile adjustments */
        @media (max-width: 768px) {
            .drawer { width: 100%; right: -100%; }
            .top-bar { padding: 0 10px; }
            .logo span { display: none; } /* Hide text logo on small screens */
            .toolbar { top: auto; bottom: 100px; left: 10px; }
            .property-bar { bottom: 10px; width: 95%; padding: 10px; }
        }

        /* Dropzone overlay */
        #drop-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(59, 130, 246, 0.8);
            z-index: 500;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            pointer-events: none;
        }

        /* Minimap */
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 160px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 100;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #minimap {
            background: #f8fafc;
            cursor: grab;
            width: 100%;
            height: 100%;
        }
        
        #minimap:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>

    <!-- Canvas Container -->
    <div id="canvas-container">
        <canvas id="c"></canvas>
    </div>

    <!-- Drag Drop Overlay -->
    <div id="drop-overlay">Upu plik tutaj</div>

    <!-- UI Layer -->
    <div id="ui-layer">
        
        <!-- Top Bar -->
        <div class="top-bar pointer-events-auto">
            <div class="logo">
                <i class="fa-solid fa-layer-group"></i> <span>Timo</span>
            </div>
            
            <div class="actions">
                <select id="lang-switcher" class="lang-select">
                    <option value="en-US"> en-US (Base)</option>
                    <option value="pl-PL">叼 pl-PL</option>
                    <option value="de-DE"> de-DE</option>
                    <option value="fr-FR"> fr-FR</option>
                    <option value="es-ES"> es-ES</option>
                </select>
                
                <button class="btn" onclick="toggleDrawer()">
                    <i class="fa-solid fa-code"></i> JSON
                </button>
                
                <div style="display:flex; align-items:center; gap:5px; margin-right:10px;">
                    <input type="checkbox" id="safe-area-toggle" onchange="toggleSafeAreas(this.checked)">
                    <span style="font-size:0.8rem; color:#64748b; cursor:pointer;" onclick="document.getElementById('safe-area-toggle').click()">Safe Area</span>
                </div>

                <div style="display:flex; align-items:center; gap:5px; margin-right:10px;">
                    <span style="font-size:0.8rem; color:#64748b;">To:</span>
                    <input type="color" id="global-bg-picker" value="#ffffff" title="Zmie to wszystkich ekran贸w" onchange="setGlobalBackground(this.value)">
                </div>

                <button class="btn primary" onclick="exportScreenshots()">
                    <i class="fa-solid fa-download"></i> Eksportuj
                </button>
            </div>
        </div>

        <!-- Left Toolbar -->
        <div class="toolbar pointer-events-auto">
            <button class="tool-btn" onclick="addText()" title="Dodaj Tekst">
                <i class="fa-solid fa-font"></i>
            </button>
            <button class="tool-btn" onclick="triggerImageUpload()" title="Dodaj Obraz">
                <i class="fa-solid fa-image"></i>
            </button>
            <input type="file" id="img-upload" hidden accept="image/*" onchange="handleImageUpload(this)">
            
            <button class="tool-btn" onclick="addFrame('ios_65')" title="Ramka iOS 6.5">
                <i class="fa-brands fa-apple"></i>
            </button>
            <button class="tool-btn" onclick="addFrame('android_phone')" title="Ramka Android">
                <i class="fa-brands fa-android"></i>
            </button>
            
            <div style="height: 1px; background: #e2e8f0; margin: 5px 0;"></div>

            <button class="tool-btn" id="pan-tool" onclick="togglePanMode()" title="Przesuwanie (Spacja)">
                <i class="fa-solid fa-hand"></i>
            </button>
        </div>

        <!-- Property Bar (Contextual) -->
        <div class="property-bar pointer-events-auto" id="prop-bar">
            <!-- Text Properties -->
            <div id="text-props" class="prop-group" style="display:none;">
                <select id="font-family" onchange="updateActiveObject('fontFamily', this.value)">
                    <option value="Arial">Arial</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Verdana">Verdana</option>
                </select>
                <input type="number" id="font-size" value="40" onchange="updateActiveObject('fontSize', parseInt(this.value))">
                <button class="btn" style="padding: 5px 10px;" onclick="toggleBold()"><i class="fa-solid fa-bold"></i></button>
                <button class="btn" style="padding: 5px 10px;" onclick="toggleItalic()"><i class="fa-solid fa-italic"></i></button>
                <!-- Alignment -->
                <button class="btn" style="padding: 5px 10px;" onclick="setTextAlign('left')"><i class="fa-solid fa-align-left"></i></button>
                <button class="btn" style="padding: 5px 10px;" onclick="setTextAlign('center')"><i class="fa-solid fa-align-center"></i></button>
                <button class="btn" style="padding: 5px 10px;" onclick="setTextAlign('right')"><i class="fa-solid fa-align-right"></i></button>
            </div>

            <!-- Frame Specific Properties -->
            <div id="frame-props" class="prop-group" style="display:none;">
                <span style="font-size: 0.8rem; color: #64748b; margin-right: 5px;">Klonuj do:</span>
                <select id="clone-target" onchange="cloneFrameTo(this.value)">
                    <option value="">Wybierz...</option>
                    <option value="ios_65">iPhone 6.5"</option>
                    <option value="ios_55">iPhone 5.5"</option>
                    <option value="ipad_129">iPad 12.9"</option>
                    <option value="android_phone">Android Phone</option>
                    <option value="android_tablet7">Android Tablet 7"</option>
                    <option value="android_tablet10">Android Tablet 10"</option>
                </select>
            </div>

            <!-- Common Properties -->
            <div class="prop-group">
                <input type="color" id="fill-color" onchange="updateActiveObject('fill', this.value)">
                <button class="btn" id="ratio-lock-btn" style="padding: 5px 10px;" onclick="toggleAspectRatio()" title="Zablokuj/Odblokuj proporcje">
                    <i class="fa-solid fa-lock"></i>
                </button>
            </div>
            
            <!-- Layer Properties -->
            <div class="prop-group">
                <button class="btn" style="padding: 5px;" onclick="bringToFront()" title="Na wierzch"><i class="fa-solid fa-arrow-up"></i></button>
                <button class="btn" style="padding: 5px;" onclick="sendToBack()" title="Na sp贸d"><i class="fa-solid fa-arrow-down"></i></button>
                <button class="btn" style="padding: 5px;" onclick="deleteActive()" title="Usu"><i class="fa-solid fa-trash text-red-500"></i></button>
            </div>
        </div>

        <!-- JSON Drawer -->
        <div class="drawer pointer-events-auto" id="json-drawer">
            <div class="drawer-header">
                <span>Localization Hub (JSON)</span>
                <button class="tool-btn" onclick="toggleDrawer()"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="drawer-content">
                <p style="font-size: 0.8rem; color: #64748b;">
                    Edytuj teksty poni偶ej lub skopiuj do AI (np. ChatGPT), aby przetumaczy na inne jzyki.
                </p>
                <div class="actions" style="margin-bottom: 10px;">
                    <button class="btn" onclick="copyJSON()">Kopiuj</button>
                    <button class="btn primary" onclick="applyJSON()">Zastosuj</button>
                </div>
                <textarea id="json-editor" class="json-editor"></textarea>
            </div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap-container" class="pointer-events-auto">
            <canvas id="minimap"></canvas>
        </div>

        <!-- Toast Notification -->
        <div id="toast" class="toast">Action completed</div>

        <!-- Minimap -->
        <div id="minimap-container" class="pointer-events-auto">
            <canvas id="minimap"></canvas>
        </div>

    </div>

    <script>
        // --- 1. STATE MANAGEMENT ---
        const state = {
            currentLang: 'en-US',
            translations: {
                'en-US': {},
                'pl-PL': {},
                'de-DE': {},
                'fr-FR': {},
                'es-ES': {}
            },
            canvasBg: '#f0f0f0',
            clipboard: null,
            undoStack: [],
            redoStack: [],
            isProcessingHistory: false
        };

        // --- 2. CONFIGURATION ---
        const FRAMES = {
            'ios_65': { width: 1284, height: 2778, name: 'iPhone 6.5"' },
            'ios_55': { width: 1242, height: 2208, name: 'iPhone 5.5"' },
            'ipad_129': { width: 2048, height: 2732, name: 'iPad 12.9"' },
            'android_phone': { width: 1080, height: 1920, name: 'Android Phone' },
            'android_tablet7': { width: 1200, height: 1920, name: 'Android Tablet 7"' },
            'android_tablet10': { width: 1600, height: 2560, name: 'Android Tablet 10"' },
        };

        // --- 3. CANVAS SETUP ---
        const canvas = new fabric.Canvas('c', {
            backgroundColor: '#f1f5f9',
            preserveObjectStacking: true,
            selection: true,
            uniformScaling: true
        });

        // --- HISTORY (UNDO/REDO) ---
        function saveHistory() {
            if (state.isProcessingHistory) return;
            
            // Limit stack size to 50 for performance
            if (state.undoStack.length > 50) state.undoStack.shift();
            
            // Don't serialize 'frameLabel' (runtime ref), use IDs instead
            state.undoStack.push(JSON.stringify(canvas.toJSON(['id', 'textId', 'isFrame', 'deviceName', 'isSafeArea', 'linkedFrameId'])));
            state.redoStack = []; // Clear redo on new action
        }

        function undo() {
            if (state.undoStack.length <= 1) return; // Keep initial state
            
            state.isProcessingHistory = true;
            const currentState = state.undoStack.pop();
            state.redoStack.push(currentState);
            
            const prevState = state.undoStack[state.undoStack.length - 1];
            
            canvas.loadFromJSON(prevState, function() {
                const objects = canvas.getObjects();
                
                // Restore frame-label links
                const frames = objects.filter(o => o.isFrame);
                const labels = objects.filter(o => o.linkedFrameId);

                // 1. Try ID based linking (New robust way)
                labels.forEach(label => {
                    const frame = frames.find(f => f.id === label.linkedFrameId);
                    if (frame) frame.frameLabel = label;
                });

                // 2. Fallback heuristic (Old way, for pre-ID states in stack)
                frames.forEach(frame => {
                    if (!frame.frameLabel && frame.deviceName) {
                        frame.frameLabel = objects.find(o => 
                            !o.selectable && 
                            o.text === frame.deviceName && 
                            o.top < frame.top && 
                            Math.abs(o.left - frame.left) < 5 // Check alignment too
                        );
                    }
                });
                
                canvas.renderAll();
                state.isProcessingHistory = false;
                showToast("Cofnito zmian");
            });
        }

        // Keyboard listeners
        window.addEventListener('keydown', function(e) {
            // Ignore if focus is on an input/textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // Ctrl + Z (Undo)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }

            // Ctrl + C (Copy)
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                e.preventDefault();
                copy();
            }

            // Ctrl + V (Paste)
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                e.preventDefault();
                paste();
            }

            // Ctrl + A (Select All)
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                canvas.discardActiveObject();
                const sel = new fabric.ActiveSelection(canvas.getObjects().filter(o => !o.excludeFromExport), {
                    canvas: canvas,
                });
                canvas.setActiveObject(sel);
                canvas.requestRenderAll();
            }
            
            // Delete / Backspace (Delete Active)
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // Check if not editing text inside canvas
                const active = canvas.getActiveObject();
                if (active && !active.isEditing) {
                    e.preventDefault();
                    deleteActive();
                }
            }
        });

        // --- COPY / PASTE ---
        function copy() {
            const activeObj = canvas.getActiveObject();
            if (!activeObj) return;
            
            activeObj.clone(function(cloned) {
                state.clipboard = cloned;
                showToast("Skopiowano");
            }, ['textId', 'isFrame', 'deviceName', 'isSafeArea', 'frameLabel', 'uniformScaling']);
        }

        function paste() {
            if (!state.clipboard) return;
            
            state.clipboard.clone(function(clonedObj) {
                canvas.discardActiveObject();
                
                clonedObj.set({
                    left: clonedObj.left + 20,
                    top: clonedObj.top + 20,
                    evented: true,
                });

                if (clonedObj.type === 'activeSelection') {
                    // Active selection needs a canvas reference
                    clonedObj.canvas = canvas;
                    clonedObj.forEachObject(function(obj) {
                        canvas.add(obj);
                        handlePastedObject(obj);
                    });
                    clonedObj.setCoords();
                } else {
                    canvas.add(clonedObj);
                    handlePastedObject(clonedObj);
                }
                
                // Fix: if we pasted a frame, we need to handle its label if it wasn't part of a group selection
                // But since 'frameLabel' link is custom, standard clone won't deep copy the label instance unless we manually do it.
                // For simplicity in this prototype, we might lose the label link or it points to original. 
                // Let's rely on `handlePastedObject` to fix basic props.
                
                canvas.setActiveObject(clonedObj);
                canvas.requestRenderAll();
                saveHistory();
                saveLocalState();
                showToast("Wklejono");
            }, ['textId', 'isFrame', 'deviceName', 'isSafeArea', 'frameLabel', 'uniformScaling']);
        }

        function handlePastedObject(obj) {
            // 1. Handle Text IDs (New Instance = New ID)
            if (obj.textId) {
                const oldId = obj.textId;
                const newId = uuidv4();
                obj.textId = newId;
                
                // Copy translation entries for all languages
                Object.keys(state.translations).forEach(lang => {
                    const text = state.translations[lang][oldId] || "";
                    state.translations[lang][newId] = text;
                });
            }

            // 2. Handle Frames (need new labels)
            if (obj.isFrame && obj.deviceName) {
                // Generate new ID for the pasted frame
                const newFrameId = uuidv4();
                obj.id = newFrameId;

                const newLabel = new fabric.Text(obj.deviceName, {
                    left: obj.left,
                    top: obj.top - 50,
                    fontSize: 30,
                    fill: '#64748b',
                    selectable: false,
                    evented: false,
                    excludeFromExport: true,
                    linkedFrameId: newFrameId // Link to new frame ID
                });
                
                obj.frameLabel = newLabel;
                canvas.add(newLabel);
                canvas.sendToBack(obj); // Ensure frame is behind
            }
        }

        // Listen for canvas changes
        canvas.on('object:added', () => { saveHistory(); debouncedSave(); });
        canvas.on('object:modified', () => { saveHistory(); debouncedSave(); });
        canvas.on('object:removed', () => { saveHistory(); debouncedSave(); });
        canvas.on('text:changed', () => { saveHistory(); debouncedSave(); }); // Ensure text changes trigger save

        // --- LOCAL STORAGE PERSISTENCE (UPGRADED TO INDEXEDDB) ---
        const LOCAL_STORAGE_KEY = 'timo_v1_db';
        let saveTimeout = null;

        function debouncedSave() {
            // Show "Saving..." status immediately
            const t = document.getElementById('toast');
            if (t.textContent !== "Zapisywanie...") {
                t.textContent = "Zapisywanie...";
                t.classList.add('show');
            }

            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveLocalState, 500); // Reduced to 500ms
        }

        async function saveLocalState() {
            if (state.isProcessingHistory) return;

            const dataToSave = {
                version: '1.1',
                currentLang: state.currentLang,
                translations: state.translations,
                // Removed 'frameLabel' from toJSON to avoid circular refs/duplication. 
                // We rely on 'linkedFrameId' and 'id' to restore links.
                canvas: canvas.toJSON(['id', 'textId', 'isFrame', 'deviceName', 'isSafeArea', 'linkedFrameId'])
            };

            try {
                await localforage.setItem(LOCAL_STORAGE_KEY, dataToSave);
                
                // Show "Saved" confirmation
                const t = document.getElementById('toast');
                t.textContent = "Zapisano";
                setTimeout(() => t.classList.remove('show'), 1000);
            } catch (e) {
                console.error('Failed to save to IndexedDB', e);
                showToast('Bd autozapisu!');
            }
        }

        async function loadLocalState() {
            try {
                const savedData = await localforage.getItem(LOCAL_STORAGE_KEY);
                if (!savedData) {
                    saveHistory(); // Initialize history
                    return;
                }
                
                // Restore State
                state.currentLang = savedData.currentLang || 'en-US';
                state.translations = savedData.translations || state.translations;
                
                // Update UI for state
                document.getElementById('lang-switcher').value = state.currentLang;
                updateJSONEditor();

                // Restore Canvas
                if (savedData.canvas) {
                    state.isProcessingHistory = true;
                    canvas.loadFromJSON(savedData.canvas, function() {
                        const objects = canvas.getObjects();
                        // Restore frame-label links using IDs
                        const frames = objects.filter(o => o.isFrame);
                        const linkedObjects = objects.filter(o => o.linkedFrameId);

                        linkedObjects.forEach(obj => {
                            const frame = frames.find(f => f.id === obj.linkedFrameId);
                            if (frame) {
                                if (obj.isSafeArea) {
                                    frame.safeArea = obj;
                                } else {
                                    frame.frameLabel = obj;
                                }
                            }
                        });
                        
                        canvas.renderAll();
                        state.isProcessingHistory = false;
                        saveHistory();
                        showToast("Przywr贸cono sesj");
                    });
                }
            } catch (e) {
                console.error('Error loading state', e);
                saveHistory();
            }
        }

        // Initial load
        loadLocalState();

        // --- GRID IMPLEMENTATION ---
        const gridSize = 50;
        
        canvas.on('before:render', function() {
            const context = canvas.getContext();
            const vpt = canvas.viewportTransform;
            const zoom = canvas.getZoom();
            
            // Only draw grid if zoom is reasonable
            if (zoom < 0.2) return;

            const viewportWidth = canvas.width / zoom;
            const viewportHeight = canvas.height / zoom;
            
            const startX = -vpt[4] / zoom;
            const startY = -vpt[5] / zoom;
            const endX = startX + viewportWidth;
            const endY = startY + viewportHeight;

            context.beginPath();
            context.strokeStyle = '#e2e8f0';
            context.lineWidth = 1 / zoom;

            // Vertical lines
            const offsetX = startX % gridSize;
            for (let i = startX - offsetX; i < endX; i += gridSize) {
                const screenX = (i * zoom) + vpt[4];
                context.moveTo(screenX, 0);
                context.lineTo(screenX, canvas.height);
            }

            // Horizontal lines
            const offsetY = startY % gridSize;
            for (let i = startY - offsetY; i < endY; i += gridSize) {
                const screenY = (i * zoom) + vpt[5];
                context.moveTo(0, screenY);
                context.lineTo(canvas.width, screenY);
            }
            
            context.stroke();
        });

        // --- CLIPPING / MASKING LOGIC ---
        
        function checkForClipping(obj) {
            // Only apply to images as requested, or extend to all if needed
            if (!obj || obj.isFrame || obj.type !== 'image') return;

            const center = obj.getCenterPoint();
            const frames = canvas.getObjects().filter(o => o.isFrame);
            
            // Find frame that contains the image center
            const targetFrame = frames.find(f => f.containsPoint(center));
            
            if (targetFrame) {
                // Create a clone of the frame to serve as the clip mask
                // We use absolutePositioned = true so it works in world coordinates
                const clipRect = new fabric.Rect({
                    left: targetFrame.left,
                    top: targetFrame.top,
                    width: targetFrame.width,
                    height: targetFrame.height,
                    scaleX: targetFrame.scaleX,
                    scaleY: targetFrame.scaleY,
                    angle: targetFrame.angle,
                    rx: targetFrame.rx,
                    ry: targetFrame.ry,
                    absolutePositioned: true,
                    originX: targetFrame.originX,
                    originY: targetFrame.originY
                });

                obj.clipPath = clipRect;
                obj.clippedByFrameId = targetFrame.id;
                obj.dirty = true;
                // showToast("Obraz przycity do ramki");
            } else {
                // Unclip if moved out
                if (obj.clipPath) {
                    obj.clipPath = null;
                    delete obj.clippedByFrameId;
                    obj.dirty = true;
                }
            }
        }

        function syncFrameClips(frame) {
            if (!frame.isFrame) return;
            
            const objs = canvas.getObjects();
            objs.forEach(obj => {
                if (obj.clippedByFrameId === frame.id && obj.clipPath) {
                    // Update the mask to match the frame's new transform
                    obj.clipPath.set({
                        left: frame.left,
                        top: frame.top,
                        width: frame.width,
                        height: frame.height,
                        scaleX: frame.scaleX,
                        scaleY: frame.scaleY,
                        angle: frame.angle,
                        skewX: frame.skewX,
                        skewY: frame.skewY
                    });
                    obj.dirty = true;
                }
            });
        }

        // --- SNAPPING LOGIC ---
        const SNAP_DIST = 10;
        
        canvas.on('object:moving', function(e) {
            const obj = e.target;
            const vpt = canvas.viewportTransform;
            
            // Snap to Grid
            if (!e.e.shiftKey) { // Hold shift to disable snap
                obj.left = Math.round(obj.left / gridSize) * gridSize;
                obj.top = Math.round(obj.top / gridSize) * gridSize;
            }
            
            // Move Linked Label (if Frame)
            if (obj.isFrame && obj.frameLabel) {
                obj.frameLabel.set({
                    left: obj.left,
                    top: obj.top - 50 // Keep relative offset
                });
            }

            // Sync clips if moving a frame
            if (obj.isFrame) {
                syncFrameClips(obj);
                updateSafeAreaPosition(obj);
            }
        });

        canvas.on('object:scaling', function(e) {
            if (e.target.isFrame) {
                syncFrameClips(e.target);
                updateSafeAreaPosition(e.target);
            }
        });

        // Resize handling
        function resizeCanvas() {
            canvas.setWidth(window.innerWidth);
            canvas.setHeight(window.innerHeight);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- 4. PANNING & ZOOMING (Infinite Canvas) ---
        let isPanning = false;
        let lastPosX, lastPosY;

        // Desktop Wheel Zoom
        canvas.on('mouse:wheel', function(opt) {
            var delta = opt.e.deltaY;
            var zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            if (zoom > 20) zoom = 20;
            if (zoom < 0.01) zoom = 0.01;
            canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
            opt.e.preventDefault();
            opt.e.stopPropagation();
        });

        // Touch Gestures (Pinch Zoom & Pan)
        let lastTouchDistance = 0;
        let isTouchDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;

        canvas.upperCanvasEl.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                // Pinch start
                isTouchDragging = false;
                const p1 = {x: e.touches[0].clientX, y: e.touches[0].clientY};
                const p2 = {x: e.touches[1].clientX, y: e.touches[1].clientY};
                lastTouchDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            } else if (e.touches.length === 1) {
                // Pan start (if mode is active or implicitly on bg)
                const target = canvas.findTarget(e);
                // Allow pan if not targeting an object or if pan tool is active
                if (!target || document.getElementById('pan-tool').classList.contains('active')) {
                     isTouchDragging = true;
                     lastTouchX = e.touches[0].clientX;
                     lastTouchY = e.touches[0].clientY;
                }
            }
        });

        canvas.upperCanvasEl.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2) {
                // Pinch Zoom
                e.preventDefault(); // Prevent browser zoom
                const p1 = {x: e.touches[0].clientX, y: e.touches[0].clientY};
                const p2 = {x: e.touches[1].clientX, y: e.touches[1].clientY};
                const currentDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);

                if (lastTouchDistance > 0) {
                    const scale = currentDistance / lastTouchDistance;
                    let zoom = canvas.getZoom() * scale;
                    if (zoom > 5) zoom = 5;
                    if (zoom < 0.1) zoom = 0.1;
                    
                    // Zoom to center of pinch
                    const centerPoint = new fabric.Point(
                        (p1.x + p2.x) / 2,
                        (p1.y + p2.y) / 2
                    );
                    
                    canvas.zoomToPoint(centerPoint, zoom);
                    canvas.requestRenderAll();
                }
                lastTouchDistance = currentDistance;
            } else if (e.touches.length === 1 && isTouchDragging) {
                // Touch Pan
                e.preventDefault();
                const x = e.touches[0].clientX;
                const y = e.touches[0].clientY;
                const vpt = canvas.viewportTransform;
                vpt[4] += x - lastTouchX;
                vpt[5] += y - lastTouchY;
                canvas.requestRenderAll();
                lastTouchX = x;
                lastTouchY = y;
            }
        });

        canvas.upperCanvasEl.addEventListener('touchend', function(e) {
            isTouchDragging = false;
            lastTouchDistance = 0;
        });

        canvas.on('mouse:down', function(opt) {
            var evt = opt.e;
            // Alt Key, Pan Tool active, OR Middle Mouse Button (button === 1)
            if (evt.altKey || document.getElementById('pan-tool').classList.contains('active') || evt.button === 1) {
                if (evt.button === 1) {
                    evt.preventDefault();
                    evt.stopPropagation();
                }
                this.isDragging = true;
                this.selection = false;
                this.lastPosX = evt.clientX;
                this.lastPosY = evt.clientY;
            }
        });

        canvas.on('mouse:move', function(opt) {
            if (this.isDragging) {
                var e = opt.e;
                var vpt = this.viewportTransform;
                vpt[4] += e.clientX - this.lastPosX;
                vpt[5] += e.clientY - this.lastPosY;
                this.requestRenderAll();
                this.lastPosX = e.clientX;
                this.lastPosY = e.clientY;
            }
        });

        canvas.on('mouse:up', function(opt) {
            this.setViewportTransform(this.viewportTransform);
            this.isDragging = false;
            this.selection = true;
            
            // Check for clipping on drop
            if (opt.target) checkForClipping(opt.target);
        });

        function togglePanMode() {
            const btn = document.getElementById('pan-tool');
            btn.classList.toggle('active');
            canvas.defaultCursor = btn.classList.contains('active') ? 'grab' : 'default';
        }

        // --- 5. LOGIC: ADDING OBJECTS ---

        // Helper: Generate UUID
        function uuidv4() {
            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        // Add Text
        function addText(initialText = "Nag贸wek") {
            const id = uuidv4();
            const textObj = new fabric.Textbox(initialText, {
                left: 100 - canvas.viewportTransform[4], // Adjust for pan
                top: 100 - canvas.viewportTransform[5],
                width: 300,
                fontSize: 40,
                fontFamily: 'Arial',
                fill: '#000000',
                textAlign: 'center',
                textId: id // Custom property to link with JSON
            });

            // Add to translation state
            state.translations[state.currentLang][id] = initialText;
            // Pre-fill other languages with same text to avoid empty
            Object.keys(state.translations).forEach(lang => {
                if(lang !== state.currentLang) state.translations[lang][id] = initialText;
            });

            canvas.add(textObj);
            canvas.setActiveObject(textObj);
            updateJSONEditor();
        }

        // Add Frame (Rectangle representation for now)
        function addFrame(type) {
            const config = FRAMES[type];
            if (!config) return;

            const id = uuidv4();

            const rect = new fabric.Rect({
                left: (window.innerWidth / 2 - config.width / 4) - canvas.viewportTransform[4],
                top: (window.innerHeight / 2 - config.height / 4) - canvas.viewportTransform[5],
                width: config.width,
                height: config.height,
                fill: '#ffffff',
                stroke: '#cbd5e1',
                strokeWidth: 2,
                rx: 40, // Rounded Corners
                ry: 40,
                shadow: '0 10px 20px rgba(0,0,0,0.1)',
                objectCaching: false,
                isFrame: true, // Custom flag
                deviceName: config.name,
                id: id
            });
            
            // Text Label for the frame
            const label = new fabric.Text(config.name, {
                left: rect.left,
                top: rect.top - 50,
                fontSize: 30,
                fill: '#64748b',
                selectable: false,
                evented: false,
                excludeFromExport: true,
                linkedFrameId: id
            });

            // Link them
            rect.frameLabel = label;

            // Scale down if huge (default view)
            if (config.width > 1000) {
                rect.scale(0.5); 
                label.set({ top: rect.top - 50 });
            }

            canvas.add(rect);
            canvas.add(label);
            canvas.sendToBack(rect);
            canvas.renderAll();
        }

        // ... [Image Handling and Drop logic same as before] ...

        // Safe Area Logic
        function updateSafeAreaPosition(frame) {
            if (!frame.safeArea) return;
            const margin = Math.min(frame.width * frame.scaleX, frame.height * frame.scaleY) * 0.05;
            frame.safeArea.set({
                left: frame.left + margin,
                top: frame.top + margin,
                width: (frame.width * frame.scaleX) - (margin * 2),
                height: (frame.height * frame.scaleY) - (margin * 2),
                scaleX: 1, 
                scaleY: 1,
                angle: frame.angle
            });
            frame.safeArea.setCoords();
        }

        function toggleSafeAreas(show) {
            const objects = canvas.getObjects();
            
            if (!show) {
                // Remove existing safe areas
                const overlays = objects.filter(o => o.isSafeArea);
                overlays.forEach(o => {
                    canvas.remove(o);
                    if (o.linkedFrameId) {
                         const frame = objects.find(f => f.id === o.linkedFrameId);
                         if (frame) delete frame.safeArea;
                    }
                });
            } else {
                // Add safe areas to all frames
                const frames = objects.filter(o => o.isFrame);
                frames.forEach(frame => {
                    if (!frame.id) frame.id = uuidv4();

                    const margin = Math.min(frame.width * frame.scaleX, frame.height * frame.scaleY) * 0.05; // 5% margin
                    
                    const safeRect = new fabric.Rect({
                        left: frame.left + margin,
                        top: frame.top + margin,
                        width: (frame.width * frame.scaleX) - (margin * 2),
                        height: (frame.height * frame.scaleY) - (margin * 2),
                        fill: 'transparent',
                        stroke: 'rgba(255, 0, 0, 0.5)',
                        strokeWidth: 2,
                        strokeDashArray: [10, 10],
                        selectable: false,
                        evented: false,
                        isSafeArea: true,
                        linkedFrameId: frame.id
                    });
                    
                    frame.safeArea = safeRect;
                    canvas.add(safeRect);
                });
            }
            canvas.renderAll();
        }

        function setTextAlign(align) {
             updateActiveObject('textAlign', align);
        }

        // Image Handling
        function triggerImageUpload() {
            document.getElementById('img-upload').click();
        }

        function handleImageUpload(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                fabric.Image.fromURL(e.target.result, function(img) {
                    img.set({
                        left: 200,
                        top: 200,
                        scaleX: 0.5,
                        scaleY: 0.5
                    });
                    canvas.add(img);
                    canvas.setActiveObject(img);
                });
            };
            reader.readAsDataURL(file);
            input.value = ''; // Reset
        }
        
        // Drag and Drop Logic
        const dropOverlay = document.getElementById('drop-overlay');
        
        window.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dropOverlay.style.display = 'flex';
        });
        
        dropOverlay.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropOverlay.style.display = 'none';
        });
        
        dropOverlay.addEventListener('dragover', (e) => { e.preventDefault(); });
        
        dropOverlay.addEventListener('drop', (e) => {
            e.preventDefault();
            dropOverlay.style.display = 'none';
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(f) {
                        fabric.Image.fromURL(f.target.result, function(img) {
                            img.set({
                                left: e.clientX,
                                top: e.clientY
                            });
                            canvas.add(img);
                        });
                    };
                    reader.readAsDataURL(file);
                }
            }
        });

        // --- 6. LOGIC: INTERACTION & PROPERTIES ---

        const propBar = document.getElementById('prop-bar');
        const textProps = document.getElementById('text-props');
        const fillColor = document.getElementById('fill-color');
        const fontSizeInput = document.getElementById('font-size');
        const fontFamilySelect = document.getElementById('font-family');

        const frameProps = document.getElementById('frame-props');
        const cloneTargetSelect = document.getElementById('clone-target');

        canvas.on('selection:created', handleSelection);
        canvas.on('selection:updated', handleSelection);
        canvas.on('selection:cleared', () => {
            propBar.classList.remove('visible');
        });

        function handleSelection(e) {
            const obj = e.selected[0];
            if (!obj) return;

            propBar.classList.add('visible');
            
            // Common
            fillColor.value = obj.fill || '#ffffff';
            
            // Update lock button state
            const lockBtn = document.getElementById('ratio-lock-btn');
            // Check if uniformScaling is explicitly false (unlocked)
            if (obj.uniformScaling === false) {
                 lockBtn.innerHTML = '<i class="fa-solid fa-lock-open"></i>';
            } else {
                 lockBtn.innerHTML = '<i class="fa-solid fa-lock"></i>';
            }

            // Frame Specific
            if (obj.isFrame) {
                frameProps.style.display = 'flex';
                cloneTargetSelect.value = ""; // Reset selection
            } else {
                frameProps.style.display = 'none';
            }

            // Text Specific
            if (obj.type === 'textbox' || obj.type === 'text' || obj.type === 'i-text') {
                textProps.style.display = 'flex';
                fontSizeInput.value = obj.fontSize;
                fontFamilySelect.value = obj.fontFamily;
            } else {
                textProps.style.display = 'none';
            }
        }

        // Smart Clone Logic
        function cloneFrameTo(targetKey) {
            if (!targetKey) return;
            
            const originalFrame = canvas.getActiveObject();
            if (!originalFrame || !originalFrame.isFrame) return;

            const targetConfig = FRAMES[targetKey];
            if (!targetConfig) return;

            // 1. Create New Frame
            // Offset it by some amount so it doesn't overlap perfectly
            const newFrameLeft = originalFrame.left + originalFrame.width + 100;
            const newFrameTop = originalFrame.top;

            const newFrame = new fabric.Rect({
                left: newFrameLeft,
                top: newFrameTop,
                width: targetConfig.width,
                height: targetConfig.height,
                fill: originalFrame.fill, // Copy bg color
                stroke: '#cbd5e1',
                strokeWidth: 2,
                shadow: '0 10px 20px rgba(0,0,0,0.1)',
                objectCaching: false,
                isFrame: true,
                deviceName: targetConfig.name
            });

            // Label for new frame
            const newLabel = new fabric.Text(targetConfig.name, {
                left: newFrameLeft,
                top: newFrameTop - 40,
                fontSize: 30,
                fill: '#64748b',
                selectable: false
            });
            
            // 2. Find objects "inside" or overlapping the original frame
            const objects = canvas.getObjects();
            const objectsToClone = [];

            objects.forEach(obj => {
                if (obj === originalFrame || obj.text === originalFrame.deviceName) return; // Skip self and label
                if (obj.selectable === false) return; // Skip non-interactive

                // Simple collision detection or checking if center is inside
                if (obj.intersectsWithObject(originalFrame) || originalFrame.containsPoint(obj.getCenterPoint())) {
                    objectsToClone.push(obj);
                }
            });

            canvas.add(newFrame);
            canvas.add(newLabel);
            canvas.sendToBack(newFrame);

            // 3. Clone and Reposition Content
            if (objectsToClone.length > 0) {
                objectsToClone.forEach(obj => {
                    obj.clone(function(cloned) {
                        // Calculate relative position from original center
                        const origCenter = originalFrame.getCenterPoint();
                        const objCenter = obj.getCenterPoint();
                        const diffX = objCenter.x - origCenter.x;
                        const diffY = objCenter.y - origCenter.y;

                        // Place on new frame center + diff
                        // Note: This preserves absolute offset from center. 
                        // For better "responsive" design, we might want percentage based, 
                        // but centering is a safe default for "Smart Clone".
                        
                        const newCenterX = newFrameLeft + (targetConfig.width / 2) + diffX;
                        const newCenterY = newFrameTop + (targetConfig.height / 2) + diffY;

                        cloned.set({
                            left: newCenterX - (cloned.width * cloned.scaleX) / 2, // approximate origin correction
                            top: newCenterY - (cloned.height * cloned.scaleY) / 2,
                            textId: obj.textId // CRITICAL: Keep same ID for translation sync!
                        });

                        // Adjust origin if needed (Fabric defaults to Top/Left usually)
                        // More precise:
                        cloned.setPositionByOrigin(
                            new fabric.Point(newCenterX, newCenterY), 
                            'center', 
                            'center'
                        );

                        canvas.add(cloned);
                    });
                });
            }

            canvas.renderAll();
            showToast(`Sklonowano do ${targetConfig.name}`);
            
            // Reset selector
            cloneTargetSelect.value = "";
        }

        function updateActiveObject(prop, value) {
            const obj = canvas.getActiveObject();
            if (obj) {
                obj.set(prop, value);
                canvas.requestRenderAll();
                saveHistory();
                saveLocalState();
            }
        }

        // Global Background
        function setGlobalBackground(color) {
            const objects = canvas.getObjects();
            let count = 0;
            objects.forEach(obj => {
                if (obj.isFrame) {
                    obj.set('fill', color);
                    count++;
                }
            });
            canvas.renderAll();
            showToast(`Zaktualizowano to dla ${count} ekran贸w`);
            saveHistory();
            saveLocalState();
        }

        // Aspect Ratio Toggle
        function toggleAspectRatio() {
            const obj = canvas.getActiveObject();
            if (!obj) return;
            
            // Fabric uses 'uniformScaling' property (true = locked ratio, false = free)
            // Or 'lockUniScaling' depending on version/config.
            // Let's toggle both to be safe and update UI.
            
            const current = obj.uniformScaling;
            obj.set('uniformScaling', !current);
            
            // Update button icon
            const btn = document.getElementById('ratio-lock-btn');
            if (obj.uniformScaling) {
                btn.innerHTML = '<i class="fa-solid fa-lock"></i>';
                showToast("Proporcje: Zablokowane");
            } else {
                btn.innerHTML = '<i class="fa-solid fa-lock-open"></i>';
                showToast("Proporcje: Odblokowane");
            }
            
            canvas.requestRenderAll();
        }

        function toggleBold() {
            const obj = canvas.getActiveObject();
            if (obj && (obj.type === 'textbox' || obj.type === 'text')) {
                obj.set('fontWeight', obj.fontWeight === 'bold' ? 'normal' : 'bold');
                canvas.requestRenderAll();
            }
        }

        function toggleItalic() {
            const obj = canvas.getActiveObject();
            if (obj && (obj.type === 'textbox' || obj.type === 'text')) {
                obj.set('fontStyle', obj.fontStyle === 'italic' ? 'normal' : 'italic');
                canvas.requestRenderAll();
            }
        }
        
        function bringToFront() {
            const obj = canvas.getActiveObject();
            if(obj) { canvas.bringToFront(obj); canvas.discardActiveObject(); canvas.renderAll(); }
        }
        
        function sendToBack() {
            const obj = canvas.getActiveObject();
            if(obj) { canvas.sendToBack(obj); canvas.discardActiveObject(); canvas.renderAll(); }
        }

        function deleteActive() {
            const obj = canvas.getActiveObject();
            if (obj) {
                // If it's a frame with a label, remove label too
                if (obj.isFrame && obj.frameLabel) {
                    canvas.remove(obj.frameLabel);
                }

                // If text, remove from current translation? No, keep ID in case of undo/other langs.
                // Or maybe warn user. For now, just remove visual.
                canvas.remove(obj);
                canvas.discardActiveObject();
                canvas.renderAll();
            }
        }

        // --- 7. LOGIC: TRANSLATION SYSTEM ---

        // Listener for text editing on canvas
        canvas.on('text:changed', function(e) {
            const obj = e.target;
            if (obj.textId) {
                // Update state
                state.translations[state.currentLang][obj.textId] = obj.text;
                updateJSONEditor();
            }
        });

        // Language Switcher
        document.getElementById('lang-switcher').addEventListener('change', function(e) {
            const newLang = e.target.value;
            switchLanguage(newLang);
        });

        function switchLanguage(lang) {
            state.currentLang = lang;
            
            // Iterate all objects and update text
            const objects = canvas.getObjects();
            objects.forEach(obj => {
                if (obj.textId && state.translations[lang] && state.translations[lang][obj.textId]) {
                    obj.set('text', state.translations[lang][obj.textId]);
                }
            });
            
            canvas.renderAll();
            updateJSONEditor();
            showToast(`Jzyk zmieniony na: ${lang}`);
            saveLocalState();
        }

        // JSON Drawer Logic
        const drawer = document.getElementById('json-drawer');
        const jsonEditor = document.getElementById('json-editor');

        function toggleDrawer() {
            drawer.classList.toggle('open');
            if (drawer.classList.contains('open')) {
                updateJSONEditor();
            }
        }

        function updateJSONEditor() {
            // We show the FULL translation object or just the current lang?
            // The req says "all texts with translations". Let's show full object.
            jsonEditor.value = JSON.stringify(state.translations, null, 2);
        }

        function applyJSON() {
            try {
                const newData = JSON.parse(jsonEditor.value);
                state.translations = newData;
                // Re-apply text for current lang
                switchLanguage(state.currentLang);
                showToast("JSON zaadowany pomylnie");
            } catch (e) {
                alert("Bd JSON: " + e.message);
            }
        }

        function copyJSON() {
            jsonEditor.select();
            document.execCommand('copy');
            showToast("Skopiowano do schowka");
        }

        // --- 8. EXPORT LOGIC ---

        async function exportScreenshots() {
            showToast("Generowanie zrzut贸w... Prosz czeka.");
            const zip = new JSZip();
            
            // Save current state to restore later
            const initialLang = state.currentLang;
            const initialZoom = canvas.getZoom();
            const initialVpt = canvas.viewportTransform;

            // Find all frame objects (rectangles with isFrame=true)
            const frames = canvas.getObjects().filter(o => o.isFrame);
            
            if (frames.length === 0) {
                alert("Nie dodano 偶adnych ramek (ekran贸w). Dodaj ramk z menu po lewej.");
                return;
            }

            // We need to iterate Languages -> Frames
            const languages = Object.keys(state.translations);

            // Temporarily reset view for correct cropping
            // Actually, toDataURL with 'cropping' works best with absolute coords
            
            for (let lang of languages) {
                // 1. Switch Language
                switchLanguage(lang); // This updates text objects
                
                // Allow render to catch up (rarely needed in sync JS but good practice)
                await new Promise(r => setTimeout(r, 50));

                const langFolder = zip.folder(lang);

                for (let i = 0; i < frames.length; i++) {
                    const frame = frames[i];
                    
                    // Logic to export specific area
                    // We need to account for scale if user scaled the frame
                    const dataURL = canvas.toDataURL({
                        left: frame.left,
                        top: frame.top,
                        width: frame.width * frame.scaleX,
                        height: frame.height * frame.scaleY,
                        multiplier: 1 / frame.scaleX, // Restore original resolution if it was visually scaled down
                        format: 'png'
                    });
                    
                    // Remove header
                    const base64Data = dataURL.replace(/^data:image\/png;base64,/, "");
                    const fileName = `${frame.deviceName.replace(/\s+/g, '_')}_${i+1}.png`;
                    
                    langFolder.file(fileName, base64Data, {base64: true});
                }
            }

            // Restore original state
            switchLanguage(initialLang);

            // Generate ZIP
            zip.generateAsync({type:"blob"})
            .then(function(content) {
                saveAs(content, "timo_export.zip");
                showToast("Gotowe! Pobieranie...");
            });
        }

        // --- UTILS ---
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 3000);
        }

        // Initial call
        updateJSONEditor();

        // --- 9. MINIMAP LOGIC ---
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimapContainer = document.getElementById('minimap-container');
        
        // Resize minimap canvas to match container pixel ratio
        function resizeMinimap() {
             const rect = minimapContainer.getBoundingClientRect();
             minimapCanvas.width = rect.width;
             minimapCanvas.height = rect.height;
        }
        window.addEventListener('resize', resizeMinimap);
        resizeMinimap();

        function updateMinimap() {
            if (!minimapCtx) return;

            const width = minimapCanvas.width;
            const height = minimapCanvas.height;

            // Clear
            minimapCtx.clearRect(0, 0, width, height);

            // Get all objects bounds
            const objects = canvas.getObjects();
            if (objects.length === 0) return;
            
            // Calculate World Bounds (all objects)
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            // Helper to expand bounds
            const expandBounds = (p) => {
                if (p.x < minX) minX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.x > maxX) maxX = p.x;
                if (p.y > maxY) maxY = p.y;
            };

            objects.forEach(obj => {
                if (obj.excludeFromExport) return; 
                // getCoords returns the 4 corners of the object in absolute scene coordinates
                const coords = obj.getCoords();
                coords.forEach(expandBounds);
            });
            
            // If no valid objects found (e.g. all excluded), return
            if (minX === Infinity) return;

            // Add padding to world bounds
            const padding = 200;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;
            
            const worldWidth = maxX - minX;
            const worldHeight = maxY - minY;
            
            // Calculate Scale to fit world in minimap
            const scaleX = width / worldWidth;
            const scaleY = height / worldHeight;
            const minimapScale = Math.min(scaleX, scaleY);
            
            // Center the world in minimap
            const renderWidth = worldWidth * minimapScale;
            const renderHeight = worldHeight * minimapScale;
            const offsetX = (width - renderWidth) / 2;
            const offsetY = (height - renderHeight) / 2;

            // Draw Objects
            minimapCtx.fillStyle = '#cbd5e1';
            objects.forEach(obj => {
                if (obj.excludeFromExport) return;
                
                // Calculate AABB for the object from its coords for simple rect drawing
                // Or draw polygon for precision (simpler to draw rects for minimap usually)
                const coords = obj.getCoords();
                let objMinX = Infinity, objMinY = Infinity, objMaxX = -Infinity, objMaxY = -Infinity;
                coords.forEach(p => {
                    if (p.x < objMinX) objMinX = p.x;
                    if (p.y < objMinY) objMinY = p.y;
                    if (p.x > objMaxX) objMaxX = p.x;
                    if (p.y > objMaxY) objMaxY = p.y;
                });

                // Map to minimap coords
                const x = offsetX + (objMinX - minX) * minimapScale;
                const y = offsetY + (objMinY - minY) * minimapScale;
                const w = (objMaxX - objMinX) * minimapScale;
                const h = (objMaxY - objMinY) * minimapScale;
                
                minimapCtx.fillRect(x, y, w, h);
            });
            
            // Draw Viewport Rect
            const vpt = canvas.viewportTransform;
            const zoom = canvas.getZoom();
            
            // Viewport in world coords
            const viewX = (-vpt[4] / zoom);
            const viewY = (-vpt[5] / zoom);
            const viewW = canvas.width / zoom;
            const viewH = canvas.height / zoom;
            
            // Map viewport to minimap
            const mapVx = offsetX + (viewX - minX) * minimapScale;
            const mapVy = offsetY + (viewY - minY) * minimapScale;
            const mapVw = viewW * minimapScale;
            const mapVh = viewH * minimapScale;
            
            minimapCtx.strokeStyle = '#3b82f6';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(mapVx, mapVy, mapVw, mapVh);

            // Store transform data for interaction
            minimapCanvas.dataset.scale = minimapScale;
            minimapCanvas.dataset.minX = minX;
            minimapCanvas.dataset.minY = minY;
            minimapCanvas.dataset.offsetX = offsetX;
            minimapCanvas.dataset.offsetY = offsetY;
        }
        
        // Hook into canvas rendering
        canvas.on('after:render', updateMinimap);
        
        // Minimap Interaction
        let isNavigatingMinimap = false;
        
        function moveViewportTo(mx, my) {
            const scale = parseFloat(minimapCanvas.dataset.scale);
            const minX = parseFloat(minimapCanvas.dataset.minX);
            const minY = parseFloat(minimapCanvas.dataset.minY);
            const offsetX = parseFloat(minimapCanvas.dataset.offsetX);
            const offsetY = parseFloat(minimapCanvas.dataset.offsetY);
            
            if (!scale) return;
            
            // Reverse mapping: Minimap Coord -> World Coord
            // mx = offsetX + (worldX - minX) * scale
            // worldX = ((mx - offsetX) / scale) + minX
            
            const worldX = ((mx - offsetX) / scale) + minX;
            const worldY = ((my - offsetY) / scale) + minY;
            
            // We want worldX, worldY to be the CENTER of the screen
            // canvas.zoomToPoint is not enough, we need absolutePan logic or viewport transform
            // center of canvas screen is (width/2, height/2)
            
            const zoom = canvas.getZoom();
            
            // Calculate new vpt[4] (translateX) and vpt[5] (translateY)
            // Center of screen corresponds to World(worldX, worldY)
            // ScreenX = WorldX * zoom + vptX
            // width/2 = worldX * zoom + vptX
            // vptX = width/2 - worldX * zoom
            
            const vpt = canvas.viewportTransform;
            vpt[4] = (canvas.width / 2) - (worldX * zoom);
            vpt[5] = (canvas.height / 2) - (worldY * zoom);
            
            canvas.requestRenderAll();
        }
        
        minimapCanvas.addEventListener('mousedown', (e) => {
            isNavigatingMinimap = true;
            moveViewportTo(e.offsetX, e.offsetY);
        });
        
        window.addEventListener('mousemove', (e) => {
            if (isNavigatingMinimap) {
                // Calculate offset relative to canvas, not window
                const rect = minimapCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                moveViewportTo(x, y);
            }
        });
        
        window.addEventListener('mouseup', () => {
            isNavigatingMinimap = false;
        });

    </script>
</body>
</html>
